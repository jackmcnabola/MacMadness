---
title: "NCAA Game-By-Game Scrape"
output: html_notebook
---


```{r}
#install.packages("splitstackshape")
#install.packages("hoopR")
#install.packages("devtools")
#install.packages("magick")
#devtools::install_github("lbenz730/ncaahoopR")
library(tidyverse)
library(splitstackshape)
library(hoopR)
library(ncaahoopR)
library(xgboost) # Load XGBoost
library(caret) # Load Caret
library(OptimalCutpoints) # Load optimal cutpoints
library(ggplot2) # Load ggplot2
library(pROC) # Load proc
library(SHAPforxgboost) # Load shap for XGBoost
library(plyr) # Load plyr
library(dplyr) # Load dplyr
library(magick) # Load Magick
```

```{r}
usethis::edit_r_environ()

## Enter in your username and password as such:
#
# KP_USER = [EMAIL]
# KP_PW = [PASSWORD]
#
## simply copy and paste the above text into the edit_r_environ() and you're good to go

```



```{r}
login(user_email = Sys.getenv("KP_USER"), user_pw = Sys.getenv("KP_PW"))
```

Get Arenas NOTE: TRY AND AND LONGTITUDE/LATITUDE DATA
```{r}
tictoc::tic()
#get arenas
arenas <- kp_arenas(year = 2022)
arenas <- cSplit(arenas, "arena", sep="(")
arenas <- cSplit(arenas, "arena_2", sep = ")")
arenas <- arenas[, c("team", "year", "arena_1", "arena_2_1")]
names(arenas)[names(arenas) == "arena_1"] <- "arena"
names(arenas)[names(arenas) == "arena_2_1"] <- "capacity"
#get possession length metrics
poss_length <- kp_efficiency(min_year = 2022, max_year = 2022)
poss_length <- poss_length[, c("team","avg_poss_length_off", "avg_poss_length_def")]
#foul and bench metrics
foul_and_bench <- kp_foul_trouble(min_year = 2022, max_year = 2022)
foul_and_bench <- foul_and_bench[, c("team","adj2fp")]
#four factors
four_factors <- kp_fourfactors(min_year = 2022, max_year = 2022)
four_factors <- four_factors[, c("team", "off_e_fg_pct", "off_to_pct", "off_or_pct", "off_ft_rate",  "def_e_fg_pct", "def_to_pct", "def_or_pct", "def_ft_rate")]
#home court advantage
hca <- kp_hca()
hca <- hca[, c("team","hca")]
#height and other stats
height_etc <- kp_height(min_year = 2022, max_year = 2022)
height_etc <- height_etc[, c("team", "avg_hgt", "eff_hgt", "experience", "bench", "continuity")]
#point distribution
point_dst <- kp_pointdist(min_year = 2022, max_year = 2022)
point_dst <- point_dst[, c("team", "off_ft_pct", "off_fg_2_pct", "off_fg_3_pct", "def_ft_pct", "def_fg_2_pct", "def_fg_3_pct")]
#other stats
misc_stats <- kp_teamstats(min_year = 2022, max_year =2022)
misc_stats <- misc_stats[, c("team", "off_blk_pct", "off_a_pct", "def_blk_pct", "def_a_pct")]
tictoc::toc()
```

```{r}
arenas #arena capacity
poss_length #average possession length on offense vs what opponenent
foul_and_bench #how quickly coaches like to pull players in foul trouble
four_factors #The basis of our stats... this will undoubtedly be the most important in our regression
hca #home court advantage estimates
height_etc #team heights
point_dst #where teams get there points, and where they let up their points
misc_stats #assists and block stats which are not implemented in the four factors, although there is probably some correlation
```

Merge datasets
```{r}
#put all data frames into list
df_list <- list(arenas, poss_length, foul_and_bench, four_factors, height_etc, point_dst, misc_stats) #ignore HCA, since the tournament is neutral sight

#merge all data frames in list
kenpom_data <- df_list %>% reduce(inner_join, by='team')
```


```{r}
kenpom_data
```

Save this csv, using the current date.
```{r}
write.csv(kenpom_data,"dat_kenpom_10_29_22.csv" ,row.names = FALSE)
```


Creating a schedule df.

I'm having trouble getting an adequate schedule. At this point, I haven't really used any of the running average stats, but Martin wrote this code and i'm scared to touch it.
```{r}
tictoc::tic()
#install.packages("devtools")
#devtools::install_github("lbenz730/ncaahoopR")
library(ncaahoopR)

# Create sequence of dates to analyse
date_seq <- seq(from = as.Date("2021-11-09"), to = as.Date("2022-03-14"), by = 1)

# Extract schedule for first data
schedule <- get_master_schedule(date_seq[1])

# Extract schedule for those dates
for(i in 2:length(date_seq)){
  try(
  temp <- get_master_schedule(date_seq[i])
  )
  if(!is.null(temp)){
    schedule <- rbind.data.frame(schedule, temp)
  }
  
  temp <- NULL
}

# Create data frame to store results
basic_stats <- as.data.frame(matrix(NA, nrow = nrow(schedule), ncol = 38))

# For each game
for(i in 1:nrow(schedule)){
  # See if box scores available
  try(
  t1 <- get_boxscore(schedule$game_id[i])
  )
  # If available
  if(!is.null(t1)){
    if(names(t1)[1] == schedule$home[i]){
      # Extract home stats
    h_stat <- as.data.frame(t1[[1]])
    # Extract away stats
    a_stat <- as.data.frame(t1[[2]])
    # Store home stats
    basic_stats[i,1:19] <- h_stat[h_stat$player == "TEAM",]
    # Store away stats
    basic_stats[i,20:38] <- a_stat[a_stat$player == "TEAM",]
    } else {
            # Extract home stats
    h_stat <- as.data.frame(t1[[2]])
    # Extract away stats
    a_stat <- as.data.frame(t1[[1]])
    # Store home stats
    basic_stats[i,1:19] <- h_stat[h_stat$player == "TEAM",]
    # Store away stats
    basic_stats[i,20:38] <- a_stat[a_stat$player == "TEAM",]
    }
    
  }
  # Conver t1 back to null
  t1 <- NULL
}

# Fix names on stats data
names(basic_stats) <- c(paste(names(h_stat), "_home", sep =""), paste(names(a_stat), "_away", sep =""))

# Join stats with schedule data
fdata <- cbind.data.frame(schedule, basic_stats)

# Save combined data
save(fdata, file = "ncaa_data")


# Load combined data
load("ncaa_data")

# Create day calcualtion function
day_calc <- function(dates){
  x <- as.POSIXct(dates)
  return(floor(unclass(x)/86400))
}

# Convert game date to days
fdata$days <- day_calc(fdata$date)


fdata$home<-gsub("@","",as.character(fdata$home)) # Getting rid of the @ symbol, home
fdata$home<-gsub(" ","",as.character(fdata$home)) # Getting rid of all spaces, f
fdata$home<-gsub("'","",as.character(fdata$home)) # Getting rid of apostrophes, home
fdata$home<-gsub("&","",as.character(fdata$home)) # Getting rid of &, home

fdata$away<-gsub("@","",as.character(fdata$away)) # Getting rid of the @ symbol, home
fdata$away<-gsub(" ","",as.character(fdata$away)) # Getting rid of all spaces, f
fdata$away<-gsub("'","",as.character(fdata$away)) # Getting rid of apostrophes, home
fdata$away<-gsub("&","",as.character(fdata$away)) # Getting rid of &, home

# Create data preparation function'
# window = number of games in the past (modify to whatever)
data_prep_function <- function(fdata, window = 30){
  #'
  #' This function takes the downloaded game data and generates the past
  #' averages for games played within the window of days
  #'
  #'
  #'
  # Create data frames to store results
  team_1_off <- team_1_def <- team_2_off <- team_2_def <- 
    as.data.frame(matrix(NA, nrow = nrow(fdata), ncol = 15))
  
  # Create name vector
  name_vec <- c("FGM", "FGA", "3PTM", "3PTA", "FTM",
                "FTA", "OREB", "DREB", "REB",  "AST",
                "STL",  "BLK",  "TO",   "PF",   "PTS")
  
  # Name result columns
  names(team_1_off) <- names(team_2_off) <- names(team_1_def) <- names(team_2_def) <- name_vec
  
  
  
  # Loop through to calculate past averages
  for(i in 1:nrow(fdata)){
    
    
    # Extract previous games for team 1 offense
    temp_1h <- fdata[fdata$home == fdata$home[i] &
                          fdata$days < fdata$days[i] &
                            fdata$days > (fdata$days[i] - window), 12:26]
    
    temp_1a <- fdata[fdata$away == fdata$home[i] &
                     fdata$days < fdata$days[i] &
                       fdata$days > fdata$days[i] - window, 31:45]
    names(temp_1a) <- names(temp_1h) <- name_vec
    temp_1 <- rbind.data.frame(temp_1h, temp_1a)
    # If any exist
    if(nrow(temp_1) > 0){
      # Calculate previous averages
      team_1_off[i,] <- colMeans(temp_1, na.rm = T)
    }
    
    
    # Extract previous games for team 1 defense
    temp_2h <- fdata[fdata$away == fdata$home[i] &
                       fdata$days < fdata$days[i] &
                       fdata$days > (fdata$days[i] - window), 12:26]
    
    temp_2a <- fdata[fdata$home == fdata$home[i] &
                       fdata$days < fdata$days[i] &
                       fdata$days > fdata$days[i] - window, 31:45]
    names(temp_2a) <- names(temp_2h) <- name_vec
    temp_2 <- rbind.data.frame(temp_2h, temp_2a)
    # If any exist
    if(nrow(temp_2) > 0){
      # Calculate previous averages
      team_1_def[i,] <- colMeans(temp_2, na.rm = T)
    }
    
    
    # Extract previous games for team 2 offense
    temp_3h <- fdata[fdata$home == fdata$away[i] &
                       fdata$days < fdata$days[i] &
                       fdata$days > (fdata$days[i] - window), 12:26]
    
    temp_3a <- fdata[fdata$away == fdata$away[i] &
                       fdata$days < fdata$days[i] &
                       fdata$days > fdata$days[i] - window, 31:45]
    names(temp_3a) <- names(temp_3h) <- name_vec
    temp_3 <- rbind.data.frame(temp_3h, temp_3a)
    # If any exist
    if(nrow(temp_3) > 0){
      # Calculate previous averages
      team_2_off[i,] <- colMeans(temp_3, na.rm = T)
    }
    
    
    # Extract previous games for team 1 defense
    temp_4h <- fdata[fdata$away == fdata$away[i] &
                       fdata$days < fdata$days[i] &
                       fdata$days > (fdata$days[i] - window), 12:26]
    
    temp_4a <- fdata[fdata$home == fdata$away[i] &
                       fdata$days < fdata$days[i] &
                       fdata$days > fdata$days[i] - window, 31:45]
    names(temp_4a) <- names(temp_4h) <- name_vec
    temp_4 <- rbind.data.frame(temp_4h, temp_4a)
    # If any exist
    if(nrow(temp_4) > 0){
      # Calculate previous averages
      team_2_def[i,] <- colMeans(temp_4, na.rm = T)
    }
    
  }
    
  # Calculate pctfg, pctfg2 pctfg3, pctft
  team_1_off$pctfg <- team_1_off$FGM/team_1_off$FGA
  team_1_off$pctfg3 <- team_1_off$`3PTM`/team_1_off$`3PTA`
  team_1_off$pctft <- team_1_off$FTM/team_1_off$FTA
  
  team_2_off$pctfg <- team_2_off$FGM/team_2_off$FGA
  team_2_off$pctfg3 <- team_2_off$`3PTM`/team_2_off$`3PTA`
  team_2_off$pctft <- team_2_off$FTM/team_2_off$FTA
  
  team_1_def$pctfg <- team_1_def$FGM/team_1_def$FGA
  team_1_def$pctfg3 <- team_1_def$`3PTM`/team_1_def$`3PTA`
  team_1_def$pctft <- team_1_def$FTM/team_1_def$FTA
  
  team_2_def$pctfg <- team_2_def$FGM/team_2_def$FGA
  team_2_def$pctfg3 <- team_2_def$`3PTM`/team_2_def$`3PTA`
  team_2_def$pctft <- team_2_def$FTM/team_2_def$FTA
  
  # Give correct names
  names(team_1_off) <- paste(names(team_1_off), "_1_off", sep = "")
  names(team_2_off) <- paste(names(team_2_off), "_2_off", sep = "")
  names(team_1_def) <- paste(names(team_1_def), "_1_def", sep = "")
  names(team_2_def) <- paste(names(team_2_def), "_2_def", sep = "")
  
  # Join into results data frame
  game_data <- cbind.data.frame(fdata, team_1_off, team_1_def, team_2_off, team_2_def)
  
 
  return(game_data)
}

# Run function on data
# change window in here
m_data <- data_prep_function(fdata)
tictoc::toc()
```

### Fixing Home and Away Score
```{r}
m_data$home_score <- m_data$PTS_home
m_data$away_score <- m_data$PTS_away
#summary(m_data)
```

```{r}
mdata_2 <- na.omit(m_data[, c(1:3, 6:8, 12:26,31:45, 47:ncol(m_data) )])
schedule <- mdata_2
```

This will save the data set.
```{r}
save(schedule, file = "proc_ncaa_no_missing_10_19_22_mod.rda")
```


```{r}
schedule
```

normalize the names on the schedule dataframe

```{r}
names(schedule)[names(schedule) == "home"] <- "team_home"
names(schedule)[names(schedule) == "away"] <- "opponent_away"
schedule$team_home<-gsub("@","",as.character(schedule$team_home)) # Getting rid of the @ symbol, home
schedule$team_home<-gsub(" ","",as.character(schedule$team_home)) # Getting rid of all spaces, home
schedule$team_home<-gsub("'","",as.character(schedule$team_home)) # Getting rid of apostrophes, home
schedule$team_home<-gsub("&","",as.character(schedule$team_home)) # Getting rid of &, home

schedule$opponent_away<-gsub("@","",as.character(schedule$opponent_away)) # Getting rid of the @ symbol, away
schedule$opponent_away<-gsub(" ","",as.character(schedule$opponent_away)) # Getting rid of all spaces, away
schedule$opponent_away<-gsub("'","",as.character(schedule$opponent_away)) # Getting rid of apostrophes, away
schedule$opponent_away<-gsub("&","",as.character(schedule$opponent_away)) # Getting rid of &, away


schedule <- schedule[!(is.na(schedule$team_home) | schedule$team_home==""), ] # Dropping rows with blank home team names
schedule <- schedule[!(is.na(schedule$opponent_away) | schedule$opponent_away==""), ] #Dropping rows with blank away team names
schedule$team_home <- gsub("[^[:alnum:]]","",as.character(schedule$team_home))
schedule
```

normalize the names on the kenpom dataframe

```{r}
names(kenpom_data)[names(kenpom_data) == "team"] <- "team_home" #renaming for joining purposes
kenpom_data$team_home<-gsub(" ","",as.character(kenpom_data$team_home)) # Getting rid of all spaces
kenpom_data$team_home<-gsub("'","",as.character(kenpom_data$team_home)) # Getting rid of periods
kenpom_data$team_home<-gsub("&","",as.character(kenpom_data$team_home)) # Getting rid of &
kenpom_data$team_home<-gsub("St.", "State", as.character(kenpom_data$team_home)) # Getting rid of &
kenpom_data
```

```{r}
schedule$team_home[schedule$team_home == "AmericanUniversity"] <- "American"
schedule$team_home[schedule$team_home == "CaliforniaBaptist"] <- "CalBaptist"
schedule$team_home[schedule$team_home == "CSUBakersfield"] <- "CalStateBakersfield"
schedule$team_home[schedule$team_home == "CSUFullerton"] <- "CalStateFullerton"
schedule$team_home[schedule$team_home == "CSUNorthridge"] <- "CalStateNorthridge"
schedule$team_home[schedule$team_home == "UConn"] <- "Connecticut"
schedule$team_home[schedule$team_home == "FloridaInternational"] <- "FIU"
schedule$team_home[schedule$team_home == "Grambling"] <- "GramblingState"
schedule$team_home[schedule$team_home == "UIC"] <- "IllinoisChicago"
schedule$team_home[schedule$team_home == "KansasCity"] <- "UMKC"
schedule$team_home[schedule$team_home == "ULMonroe"] <- "LouisianaMonroe"
schedule$team_home[schedule$team_home == "LongIslandUniversity"] <- "LIU"
schedule$team_home[schedule$team_home == "McNeese"] <- "McNeeseState"
schedule$team_home[schedule$team_home == "UMass"] <- "Massachusetts"
schedule$team_home[schedule$team_home == "Miami"] <- "MiamiFL"
schedule$team_home[schedule$team_home == "OleMiss"] <- "Mississippi"
schedule$team_home[schedule$team_home == "MountStMarys"] <- "MountStateMarys"
kenpom_data$team_home[kenpom_data$team_home == "N.C.Statete"] <- "NCState"
schedule$team_home[schedule$team_home == "Omaha"] <- "NebraskaOmaha"
schedule$team_home[schedule$team_home == "Nicholls"] <- "NichollsState"
schedule$team_home[schedule$team_home == "Pennsylvania"] <- "Penn"
schedule$team_home[schedule$team_home == "SamHouston"] <- "SamHoustonState"
schedule$team_home[schedule$team_home == "SanJoséState"] <- "SanJoseState"
schedule$team_home[schedule$team_home == "SeattleU"] <- "Seattle"
schedule$team_home[schedule$team_home == "SELouisiana"] <- "SoutheasternLouisiana"
schedule$team_home[schedule$team_home == "SouthCarolinaUpstate"] <- "USCUpstate"
kenpom_data$team_home[kenpom_data$team_home == "StateBonaventure"] <- "StBonaventure"
kenpom_data$team_home[kenpom_data$team_home == "StateFrancisNY"] <- "StFrancisBKN"
kenpom_data$team_home[kenpom_data$team_home == "StateFrancisPA"] <- "StFrancisPA"
kenpom_data$team_home[kenpom_data$team_home == "Statenford"] <- "Stanford"
kenpom_data$team_home[kenpom_data$team_home == "StateJohns"] <- "StJohns"
kenpom_data$team_home[kenpom_data$team_home == "StatenyBrook"] <- "StonyBrook"
kenpom_data$team_home[kenpom_data$team_home == "StatephenF.Austin"] <- "StephenFAustin"
kenpom_data$team_home[kenpom_data$team_home == "StateThomas"] <- "StThomasMinnesota"
kenpom_data$team_home[kenpom_data$team_home == "Statetson"] <- "Stetson"
schedule$team_home[schedule$team_home == "Tarleton"] <- "TarletonState"
schedule$team_home[schedule$team_home == "UTMartin"] <- "TennesseeMartin"
schedule$team_home[schedule$team_home == "TexasAMCC"] <- "TexasAMCorpusChris"
schedule$team_home[schedule$team_home == "Hawaii"] <- "Hawaii"
kenpom_data$team_home[kenpom_data$team_home == "Hawaii"] <- "Hawaii"
schedule$team_home[schedule$team_home == "HawaiiHilo"] <- "Hawaii"
```

```{r}
kp_home <- kp_away <- as.data.frame(matrix(NA,nrow = nrow(schedule), ncol = 30))
```


```{r}
for(i in 1:nrow(kp_home)){
  if(kenpom_data$team_home[i] %in% schedule$team_home){
    kp_home[which(schedule$team_home == kenpom_data$team_home[i]),] <- kenpom_data[i,] 
  }
  if(kenpom_data$team_home[i] %in% schedule$opponent_away){
    kp_away[which(schedule$opponent_away == kenpom_data$team_home[i]),] <- kenpom_data[i,] 
  }
}

names(kp_home) <- paste(names(kenpom_data), "_home", sep ="")
names(kp_away) <- paste(names(kenpom_data), "_away", sep = "")
```

#Combine the data set
```{r}
kp_home
kp_away
schedule
```



```{r}
full_data <- (cbind.data.frame(schedule, kp_home, kp_away))
```

```{r}
full_data <- na.omit(cbind.data.frame(schedule, kp_home, kp_away))
```


somehow, we lost nearly 1,000 games? Many of these are due to teams that kenpom does not track, such as chaminade or UVI, but 1000 seems too steep. Some are due to non-recognition in names between the dataset, such as MountSt.Marys, UTMartin, Loyola(MD), and St.Marys(MD). I truly believe that the best way to fix this error is to go row by row, which will be rediculously tedious, but it is what it is. 

Because the season is already over and this xgboost is a blueprint, we will continue without using the entire 2022 gameslate.

Remove irrelevant/redundant rows. This is just team name duplicates and year columns


```{r}
full_data <- full_data[c(2:6, 114:139, 144:169)]
```



```{r}
full_data$win = 0
full_data$win[full_data$home_score > full_data$away_score] = 1
```



#Split Data
We will split the data 80/20

```{r}
set.seed(111111)
dt = sort(sample(nrow(full_data), nrow(full_data)*.8))
train_data1 <- full_data[dt,]
test_data1 <- full_data[-dt,]
```


#Check missing data and summarize data
```{r}
sum(is.na(train_data1))
sum(is.na(test_data1)) 
summary(as.factor(train_data1$win))
summary(as.factor(test_data1$win))
```

```{r}
train_data1
```


```{r} 
#Remove Characters
# must do this for categorical variables
train_data <- train_data1[c(6:58)]
test_data <- test_data1[c(6:58)]
head(train_data)
dim(train_data)
```

```{r}
##Drop Insignificant
##nothing rn
head(train_data)
head(test_data)
```

#Convert data to DMatrix
n_var should exclude the response variable, only the explanatory
1,2,3,6 are categorical, these are omitted 
```{r}
# Create training matrix
dtrain <- xgb.DMatrix(data = as.matrix(train_data[, 1:52]), label = as.numeric(train_data$win))
# Create test matrix
dtest <- xgb.DMatrix(data = as.matrix(test_data[, 1:52]), label = as.numeric(test_data$win))
```

#Train the XGBoost Model

```{r Train xgboost}
set.seed(111111)
mbst_1 <- xgboost(data = dtrain, # Set training data
               
               nrounds = 100, # Set number of rounds
               
               verbose = 1, # 1 - Prints out fit
                print_every_n = 20, # Prints out result every 20th iteration
               
               objective = "binary:logistic", # Set objective
               eval_metric = "auc",
               eval_metric = "error") # Set evaluation metric to use
```

#Predicting with XGBoost

```{r xbgoost predictions}
set.seed(111111)
boost_preds <- predict(mbst_1, dtrain) # Create predictions for xgboost model
# Join predictions and actual
pred_dat <- cbind.data.frame(boost_preds , train_data$win)
names(pred_dat) <- c("predictions", "response")
oc<- optimal.cutpoints(X = "predictions",
                       status = "response",
                       tag.healthy = 0,
                       data = pred_dat,
                       methods = "MaxEfficiency")

boost_preds_1 <- predict(mbst_1, dtest) # Create predictions for xgboost model

pred_dat <- cbind.data.frame(boost_preds_1 , test_data$win)#
# Convert predictions to classes, using optimal cut-off
boost_pred_class <- rep(0, length(boost_preds_1))
boost_pred_class[boost_preds_1 >= oc$MaxEfficiency$Global$optimal.cutoff$cutoff[1]] <- 1


t <- table(boost_pred_class, test_data$win) # Create table
confusionMatrix(t, positive = "1") # Produce confusion matrix
```
Our model is performing with around 70.75% accuracy. We will no focus on setting parameters to increase AUC rate

#Tune Model
```{r}
set.seed(111111)
mbst_tune1 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
               eta = 0.1, # Set learning rate
              
               nrounds = 200, # Set number of rounds
               early_stopping_rounds = 50, # Set number of rounds to stop at if there is no improvement
               
               verbose = 1, # 1 - Prints out fit
               nthread = 1, # Set number of parallel threads
               print_every_n = 20, # Prints out result every 20th iteration
              
               objective = "binary:logistic", # Set objective
               eval_metric = "auc",
               eval_metric = "error") # Set evaluation metric to use
```
For this portion, we will set the number of iterations to 100 and include and early stop parameter of 50 for our next round of tuning. In this round, we will adjust max.depth and min_child_weight.

```{r}
# Be Careful - This can take a very long time to run
max_depth_vals <- c(3, 5, 7, 10, 15) # Create vector of max depth values
min_child_weight <- c(1,3,5,7, 10, 15) # Create vector of min child values

# Expand grid of parameter values
cv_params <- expand.grid(max_depth_vals, min_child_weight)
names(cv_params) <- c("max_depth", "min_child_weight")
# Create results vector
auc_vec <- error_vec <- rep(NA, nrow(cv_params)) 
# Loop through results
for(i in 1:nrow(cv_params)){
  set.seed(111111)
  mbst_tune2 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.1, # Set learning rate
              max.depth = cv_params$max_depth[i], # Set max depth
              min_child_weight = cv_params$min_child_weight[i], # Set minimum number of samples in node to split
             
               
              nrounds = 100, # Set number of rounds
              early_stopping_rounds = 50, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
               
              objective = "binary:logistic", # Set objective
              eval_metric = "auc", # Set evaluation metric to use
              eval_metric = "error") # Set evaluation metric to use
  auc_vec[i] <- mbst_tune2$evaluation_log$test_auc_mean[mbst_tune2$best_ntreelimit]
  error_vec[i] <- mbst_tune2$evaluation_log$test_error_mean[mbst_tune2$best_ntreelimit]
  
}
```

To analyze the results of our max depth and minimum child relationship error, we will create a data set and a AUC heat map to visualize the optimal results of the parameters.

#Check for imbalanced Data

```{r}
# Join results in dataset
res_db <- cbind.data.frame(cv_params, auc_vec, error_vec)
names(res_db)[3:4] <- c("auc", "error") 
res_db$max_depth <- as.factor(res_db$max_depth) # Convert tree number to factor for plotting
res_db$min_child_weight <- as.factor(res_db$min_child_weight) # Convert node size to factor for plotting
# Print AUC heatmap
g_2 <- ggplot(res_db, aes(y = max_depth, x = min_child_weight, fill = auc)) + # set aesthetics
  geom_tile() + # Use geom_tile for heatmap
  theme_bw() + # Set theme
  scale_fill_gradient2(low = "blue", # Choose low color
    mid = "white", # Choose mid color
    high = "red", # Choose high color
    midpoint =mean(res_db$auc), # Choose mid point
    space = "Lab", 
    na.value ="grey", # Choose NA value
    guide = "colourbar", # Set color bar
    aesthetics = "fill") + # Select aesthetics to apply
  labs(x = "Minimum Child Weight", y = "Max Depth", fill = "AUC") # Set labels
g_2 # Generate plot
```

```{r}
g_3 <- ggplot(res_db, aes(y = max_depth, x = min_child_weight, fill = error)) + # set aesthetics
  geom_tile() + # Use geom_tile for heatmap
  theme_bw() + # Set theme
  scale_fill_gradient2(low = "blue", # Choose low color
    mid = "white", # Choose mid color
    high = "red", # Choose high color
    midpoint =mean(res_db$error), # Choose mid point
    space = "Lab", 
    na.value ="grey", # Choose NA value
    guide = "colourbar", # Set color bar
    aesthetics = "fill") + # Select aesthetics to apply
  labs(x = "Minimum Child Weight", y = "Max Depth", fill = "Error") # Set labels
g_3 # Generate plot
```

```{r}
max_dep = res_db[which.max(res_db$auc),][[1]]
max_chi = res_db[which.max(res_db$auc),][[2]]
res_db
max(res_db$auc)
min(res_db$error)
max_dep
max_chi
```
The highest AUC value is when max depth is `max_dep` and minimum child weight is `min_chi`. 

Now, we fine tune gamma, which is the minimum loss reduction necessary to make a further partition in a node.

```{r}
gamma_vals <- c(0, 0.05, 0.1, 0.15, 0.2) # Create vector of gamma values

# Be Careful - This can take a very long time to run
set.seed(111111)
auc_vec <- error_vec <- rep(NA, length(gamma_vals))
for(i in 1:length(gamma_vals)){
  mbst_tune3 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.1, # Set learning rate
              max.depth = max_dep, # Set max depth
              min_child_weight = min_chi, # Set minimum number of samples in node to split
              gamma = gamma_vals[i], # Set minimum loss reduction for split

              
               
              nrounds = 200, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
               
              objective = "binary:logistic", # Set objective
              eval_metric = "auc", # Set evaluation metric to use
              eval_metric = "error") # Set evaluation metric to use
  auc_vec[i] <- mbst_tune3$evaluation_log$test_auc_mean[mbst_tune3$best_ntreelimit]
  error_vec[i] <- mbst_tune3$evaluation_log$test_error_mean[mbst_tune3$best_ntreelimit]
  
}
```

Similar to what we did with max depth and child weight, we will bind the results into a table and find the highest AUC and the lowest error

```{r}
# Join gamma to values
bestgamma <- cbind.data.frame(gamma_vals, auc_vec, error_vec)
bestgamma
max(bestgamma$auc_vec)
max_gam = bestgamma[which.max(bestgamma$auc_vec),][[1]]
max_gam
```


It appears here that a gamma value of `max_gam` gives us the highest AUC value.

Now, we will re-calibrate the number of rounds to use for an optimal model
```{r}
# Use xgb.cv to run cross-validation inside xgboost
set.seed(111111)
mbst_tune4 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.20, # Set learning rate
              max.depth = max_dep, # Set max depth
              min_child_weight = min_chi, # Set minimum number of samples in node to split
              gamma = max_gam, # Set minimum loss reduction for split
             
               
              nrounds = 200, # Set number of rounds
              early_stopping_rounds = 50, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
               
              objective = "binary:logistic", # Set objective
              eval_metric = "auc",
              eval_metric = "error") # Set evaluation metric to use
```


```{r}
# Be Careful - This can take a very long time to run
subsample <- c(0.6, 0.7, 0.8, 0.9, 1) # Create vector of subsample values
colsample_by_tree <- c(0.6, 0.7, 0.8, 0.9, 1) # Create vector of col sample values

# Expand grid of tuning parameters
cv_params <- expand.grid(subsample, colsample_by_tree)
names(cv_params) <- c("subsample", "colsample_by_tree")
# Create vectors to store results
auc_vec <- error_vec <- rep(NA, nrow(cv_params)) 
# Loop through parameter values
for(i in 1:nrow(cv_params)){
  set.seed(111111)
  mbst_tune <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.1, # Set learning rate
              max.depth = max_dep, # Set max depth
              min_child_weight = min_chi, # Set minimum number of samples in node to split
              gamma = max_gam, # Set minimum loss reduction for split
              subsample = cv_params$subsample[i], # Set proportion of training data to use in tree
              colsample_bytree = cv_params$colsample_by_tree[i], # Set number of variables to use in each tree
               
              nrounds = 100, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
               
              objective = "binary:logistic", # Set objective
              eval_metric = "auc", # Set evaluation metric to use
              eval_metric = "error") # Set evaluation metric to use
  auc_vec[i] <- mbst_tune$evaluation_log$test_auc_mean[mbst_tune$best_ntreelimit]
  error_vec[i] <- mbst_tune$evaluation_log$test_error_mean[mbst_tune$best_ntreelimit]
  
}
```

We can now visualize the result of the model with our set parameters

```{r}
res_db2 <- cbind.data.frame(cv_params, auc_vec, error_vec)
names(res_db2)[3:4] <- c("auc", "error") 
res_db2$subsample <- as.factor(res_db2$subsample) # Convert tree number to factor for plotting
res_db2$colsample_by_tree <- as.factor(res_db2$colsample_by_tree) # Convert node size to factor for plotting
g_4 <- ggplot(res_db2, aes(y = colsample_by_tree, x = subsample, fill = auc)) + # set aesthetics
  geom_tile() + # Use geom_tile for heatmap
  theme_bw() + # Set theme
  scale_fill_gradient2(low = "blue", # Choose low color
    mid = "white", # Choose mid color
    high = "red", # Choose high color
    midpoint =mean(res_db2$auc), # Choose mid point
    space = "Lab", 
    na.value ="grey", # Choose NA value
    guide = "colourbar", # Set color bar
    aesthetics = "fill") + # Select aesthetics to apply
  labs(x = "Subsample", y = "Column Sample by Tree", fill = "AUC") # Set labels
g_4 # Generate plot
```



```{r}
g_5 <- ggplot(res_db2, aes(y = colsample_by_tree, x = subsample, fill = error)) + # set aesthetics
  geom_tile() + # Use geom_tile for heatmap
  theme_bw() + # Set theme
  scale_fill_gradient2(low = "blue", # Choose low color
    mid = "white", # Choose mid color
    high = "red", # Choose high color
    midpoint =mean(res_db2$error), # Choose mid point
    space = "Lab", 
    na.value ="grey", # Choose NA value
    guide = "colourbar", # Set color bar
    aesthetics = "fill") + # Select aesthetics to apply
  labs(x = "Subsample", y = "Column Sample by Tree", fill = "Error") # Set labels
g_5 # Generate plot
```

```{r}
res_db2
max(res_db2$auc)
min(res_db2$error)

max_sub = res_db2[which.max(res_db2$auc),][[1]]
max_col = res_db2[which.max(res_db2$auc),][[2]]

max_sub
max_col
```

Subsample parameter should be `max_sub`, the colsample_by_tree should be `max_col`. This indicates that the model is performing better when there are more samples included in the data. Low values are performing worse. This indicates that many of the variables in our data set don't add much in terms of predictive power, and trees built with those variables are poor predictors. We will use the subsample parameter value of `max_sub` and the colsample_by_tree of `max_col` in our next step. This step is setting the eta learning rate through the analysis below

```{r}
set.seed(111111)
bst_mod_1 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.3, # Set learning rate
              max.depth = max_dep, # Set max depth
              min_child_weight = max_chi, # Set minimum number of samples in node to split
              gamma = max_gam, # Set minimum loss reduction for split
              subsample = max_sub, # Set proportion of training data to use in tree
              colsample_bytree =  max_col, # Set number of variables to use in each tree
               
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              
              objective = "binary:logistic", # Set objective
              eval_metric = "auc",
              eval_metric = "error") # Set evaluation metric to use
```

```{r}
set.seed(111111)
bst_mod_2 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.1, # Set learning rate
              max.depth =  max_dep, # Set max depth
              min_child_weight = max_chi, # Set minimum number of samples in node to split
              gamma = max_gam, # Set minimum loss reduction for split
              subsample = max_sub, # Set proportion of training data to use in tree
              colsample_bytree = max_col, # Set number of variables to use in each tree
               
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              
              objective = "binary:logistic", # Set objective
              eval_metric = "auc",
              eval_metric = "error") # Set evaluation metric to use
```

```{r}
set.seed(111111)
bst_mod_3 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.05, # Set learning rate
              max.depth = max_dep, # Set max depth
              min_child_weight = max_chi, # Set minimum number of samples in node to split
              gamma = max_gam, # Set minimum loss reduction for split
              subsample = max_sub, # Set proportion of training data to use in tree
              colsample_bytree =  max_col, # Set number of variables to use in each tree
               
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              
              objective = "binary:logistic", # Set objective
              eval_metric = "auc",
              eval_metric = "error") # Set evaluation metric to use
```

```{r}
set.seed(111111)
bst_mod_4 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.01, # Set learning rate
              max.depth = max_dep, # Set max depth
              min_child_weight = max_chi, # Set minimum number of samples in node to split
              gamma = max_gam, # Set minimum loss reduction for split
              subsample = max_sub, # Set proportion of training data to use in tree
              colsample_bytree = max_col, # Set number of variables to use in each tree
               
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              
              objective = "binary:logistic", # Set objective
              eval_metric = "auc",
              eval_metric = "error") # Set evaluation metric to use
```

```{r}
set.seed(111111)
bst_mod_5 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.005, # Set learning rate
              max.depth = max_dep, # Set max depth
              min_child_weight = max_chi, # Set minimum number of samples in node to split
              gamma = max_gam, # Set minimum loss reduction for split
              subsample = max_sub, # Set proportion of training data to use in tree
              colsample_bytree = max_col, # Set number of variables to use in each tree
               
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
               
              objective = "binary:logistic", # Set objective
              eval_metric = "auc",
              eval_metric = "error") # Set evaluation metric to use
```
Now, we can plot the error rates vs. the number of trees to see which models are performing best

```{r}
# Extract results for model with eta = 0.3
pd1 <- cbind.data.frame(bst_mod_1$evaluation_log[,c("iter", "test_auc_mean")], rep(0.3, nrow(bst_mod_1$evaluation_log)))
names(pd1)[3] <- "eta"
# Extract results for model with eta = 0.1
pd2 <- cbind.data.frame(bst_mod_2$evaluation_log[,c("iter", "test_auc_mean")], rep(0.1, nrow(bst_mod_2$evaluation_log)))
names(pd2)[3] <- "eta"
# Extract results for model with eta = 0.05
pd3 <- cbind.data.frame(bst_mod_3$evaluation_log[,c("iter", "test_auc_mean")], rep(0.05, nrow(bst_mod_3$evaluation_log)))
names(pd3)[3] <- "eta"
# Extract results for model with eta = 0.01
pd4 <- cbind.data.frame(bst_mod_4$evaluation_log[,c("iter", "test_auc_mean")], rep(0.01, nrow(bst_mod_4$evaluation_log)))
names(pd4)[3] <- "eta"
# Extract results for model with eta = 0.005
pd5 <- cbind.data.frame(bst_mod_5$evaluation_log[,c("iter", "test_auc_mean")], rep(0.005, nrow(bst_mod_5$evaluation_log)))
names(pd5)[3] <- "eta"
# Join datasets
plot_data <- rbind.data.frame(pd1, pd2, pd3, pd4, pd5)
# Converty ETA to factor
plot_data$eta <- as.factor(plot_data$eta)
# Plot points
g_6 <- ggplot(plot_data, aes(x = iter, y = test_auc_mean, color = eta))+
  geom_point(alpha = 0.5) +
  theme_bw() + # Set theme
  theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid 
  labs(x = "Number of Trees", title = "AUC v Number of Trees",
       y = "AUC", color = "Learning \n Rate")  # Set labels
g_6
```


```{r}
g_7 <- ggplot(plot_data, aes(x = iter, y = test_auc_mean, color = eta))+
  geom_smooth(alpha = 0.5) +
  theme_bw() + # Set theme
  theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid 
  labs(x = "Number of Trees", title = "AUC v Number of Trees",
       y = "AUC", color = "Learning \n Rate")  # Set labels
g_7
```

```{r}
plot_data
max_iter = plot_data[which.max(plot_data$test_auc_mean),][[1]]
max_eta = plot_data[which.max(plot_data$test_auc_mean),][[3]]
max_iter
max_eta
```

The line that reaches the highest AUC has an iter of `max_iter` and a eta of `max_iter`, which we will use for our final model below.

```{r}
set.seed(111111)
bst_final <- xgboost(data = dtrain, # Set training data
              
        
               
              eta = max_eta, # Set learning rate
              max.depth =  max_dep, # Set max depth
              min_child_weight = max_chi, # Set minimum number of samples in node to split
              gamma = max_gam, # Set minimum loss reduction for split
              subsample =  max_sub, # Set proportion of training data to use in tree
              colsample_bytree = max_col, # Set number of variables to use in each tree
               
              nrounds = max_iter, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              
              objective = "binary:logistic", # Set objective
              eval_metric = "auc",
              eval_metric = "error") # Set evaluation metric to use
```
Lets examine how our tuned model performs on our test dataset

```{r}
boost_preds <- predict(bst_final, dtrain) # Create predictions for XGBoost model on training data

pred_dat <- cbind.data.frame(boost_preds , train_data$win)#
names(pred_dat) <- c("predictions", "response")
oc<- optimal.cutpoints(X = "predictions",
                       status = "response",
                       tag.healthy = 0,
                       data = pred_dat,
                       methods = "MaxEfficiency")

boost_preds <- predict(bst_final, dtest) # Create predictions for XGBoost model

pred_dat <- cbind.data.frame(boost_preds , test_data$win)#
# Convert predictions to classes, using optimal cut-off
boost_pred_class <- rep(0, length(boost_preds))
boost_pred_class[boost_preds >= oc$MaxEfficiency$Global$optimal.cutoff$cutoff[1]] <- 1


t <- table(boost_pred_class, test_data$win) # Create table
confusionMatrix(t, positive = "1") # Produce confusion matrix
```

Recall earlier that our model ws slightly imbalanced.
```{r}
summary(as.factor(train_data$win))[[1]]
summary(as.factor(train_data$win))[[2]]
```
There is a way to balance imbalanced data by creating a weight which we can use to scale the positive class weight to have equal representation

```{r}
zero_weight <- summary(as.factor(train_data$win))[[1]]/summary(as.factor(train_data$win))[[2]]
```

We can then feed this vector to xgboost using the weight parameter

```{r}
set.seed(111111)
bst_bal <- xgboost(data = dtrain, # Set training data
              
        
               
              eta = max_eta, # Set learning rate
              max.depth =  max_dep, # Set max depth
              min_child_weight = max_chi, # Set minimum number of samples in node to split
              gamma = max_gam, # Set minimum loss reduction for split
              subsample =  max_sub, # Set proportion of training data to use in tree
              colsample_bytree = max_col, # Set number of variables to use in each tree
               
              nrounds = max_iter, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              
              scale_pos_weight = zero_weight, # Set weights
              
              objective = "binary:logistic", # Set objective
              eval_metric = "auc",
              eval_metric = "error") # Set evaluation metric to use
```


```{r}
set.seed(111111)
boost_preds_bal <- predict(bst_bal, dtrain) # Create predictions for XGBoost model on training data

pred_dat <- cbind.data.frame(boost_preds_bal , train_data$win)#
names(pred_dat) <- c("predictions", "response")
oc<- optimal.cutpoints(X = "predictions",
                       status = "response",
                       tag.healthy = 0,
                       data = pred_dat,
                       methods = "MaxEfficiency")

boost_preds_bal <- predict(bst_bal, dtest) # Create predictions for XGBoost model

pred_dat <- cbind.data.frame(boost_preds_bal , test_data$win)#
# Convert predictions to classes, using optimal cut-off
boost_pred_class <- rep(0, length(boost_preds_bal))
boost_pred_class[boost_preds_bal >= oc$MaxEfficiency$Global$optimal.cutoff$cutoff[1]] <- 1


t <- table(boost_pred_class, test_data$win) # Create table
confusionMatrix(t, positive = "1") # Produce confusion matrix
```



### Variable Importance with XGBoost

```{r}
# Extract importance
imp_mat <- xgb.importance(model = bst_final)
# Plot importance.
xgb.plot.importance(imp_mat, top_n = 10)
```
Above are the most important aspects of a basketball game for the current season. As expected, they align closely with Dean Oliver's Four Factors of Basketball.


### SHAP (SHapley Additive exPlanation)
SHAP was created by Scott M. Lundberg and Su-In Lee, two computer scientist at the Paul G. Allen School of Computer Science. The goal is to understand why a model makes a certain prediction. In large models, there is a tension between accuracy and interpretability. The SHAP framework assigns each feature an importance value for a particular prediction, allowing easier human intuition when interpreting each predictor.

```{r}
install.packages("devtools")
library(devtools) 
install_github("AppliedDataSciencePartners/xgboostExplainer")
library(xgboostExplainer)
```

```{r}
explainer = buildExplainer(bst_final, dtrain, type="binary", base_score = 0.5, trees_idx = NULL) # Create explainer
```

```{r}
pred.breakdown = explainPredictions(bst_final, explainer, dtest) # Breakdown predictions
```

```{r}
nrow(test_data)
```


```{r,fig.width = 12, fig.height = 6}
showWaterfall(bst_final, explainer, dtest, as.matrix(test_data[, 1:52]) , nrow(test_data), type = "binary", threshold = 0.01)
```

Again, the results closely align to Dean Olivers Four Factors of Basketball. The SHAP model is considered to be more accurate than the previous importance plot. 

### Compare methods

By plotting the auc curves we can compare our first model against our final balanced model.

```{r}
# Calculate first model ROC
roc1 = roc(test_data$win, boost_preds_1)
```

```{r}
# Calculate final model ROC
roc2 = roc(test_data$win, boost_preds)
```

```{r, fig.width=8, fig.height=8}
# Print initial model AUC
plot.roc(roc1, print.auc = TRUE, print.auc.x = 1, print.auc.y = 1, col = "red", print.auc.col = "red")
# Print final model AUC
plot.roc(roc2, print.auc = TRUE, print.auc.x = 1, print.auc.y = 0.98, col ="blue", print.auc.col = "blue", add = TRUE)
```
AUC Improvement is shown above


## Now that we have an accurate model, we will create a tournament simulation.

```{r}
sort(unique(full_data$team_home))
```

Create Tourney Dataframe (this is currently based off of the NCAA tournament pre-first four)
```{r}
#west & east....
#as of 2/27:
Tourney <-  data.frame(Team = c(#West:
  "Gonzaga", "GeorgiaState", "Duke", "CalStateFullerton", "TexasTech", "MontanaState", "Arkansas", "Vermont", "Connecticut", "NewMexicoState", "Alabama", "NotreDame", "MichiganState", "Davidson", "BoiseState", "Memphis",
  #East:
  "Baylor","NorfolkState", "Kentucky", "SaintPeters", "Purdue", "Yale", "UCLA", "Akron", "SaintMarys", "Indiana", "Texas", "VirginiaTech", "MurrayState", "SanFrancisco", "NorthCarolina","Marquette",
  #South:
  "Arizona","WrightState","Villanova","Delaware","Tennessee","Longwood","Illinois","Chattanooga","Houston","UAB","ColoradoState","Michigan","OhioState","LoyolaChicago","SetonHall","TCU",
  #Midwest:
  "Kansas","TexasSouthern","Auburn","JacksonvilleState","Wisconsin","Colgate","Providence","SouthDakotaState","Iowa","Richmond","LSU","IowaState","USC","MiamiFL","SanDiegoState","Creighton"),

                       Seed = c("W01", "W16", "W02", "W15", "W03","W14", "W04","W13",
                                "W05","W12","W06", "W11", "W07","W10", "W08","W09",
                                "X01", "X16", "X02", "X15", "X03","X14", "X04","X13",
                                "X05","X12","X06", "X11", "X07","X10", "X08","X09","Y01",
                                "Y16", "Y02", "Y15", "Y03","Y14", "Y04","Y13", 
                                "Y05","Y12","Y06", "Y11", "Y07","Y10", "Y08","Y09",
                                "Z01", "Z16", "Z02", "Z15", "Z03","Z14", "Z04","Z13",
                                "Z05","Z12","Z06", "Z11", "Z07","Z10", "Z08","Z09"),
                       
                       
                       # Work from outsides of range building into the median to create WO1 vs. WO16 and so on reference the march madness brcket. 
                       
                       Game = c(1,1, 2,2, 3,3,4, 4,5, 5,6, 6,7, 7, 8, 8, 9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17, 17, 18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32),
                       
                       Game2 = c(1,1,2,2,3,3,4,4,4,4,3,3,2,2,1,1,5,5,6,6,7,7,8,8,8,8,7,7,6,6,5,5,9,9,10,10,11,11,12,12,12,12,11,11,10,10,9,9,13,13,14,14,15,15,16,16,16,16,15,15,14,14,13,13), # Up to 16
                       Game3 = c(1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,3,3,4,4,4,4,3,3,3,3,4,4,4,4,3,3,5,5,6,6,6,6,5,5,5,5,6,6,6,6,5,5,7,7,8,8,8,8,7,7,7,7,8,8,8,8,7,7), # Start with 8 1s up until 8
                       Game4 = c(rep(1,16), rep(2,16), rep(3,16), rep(4,16)), # 16 1s up until 4
                       
                       ### This needs reviewed, but I am making the assumption the bracketed quadrants are labeled clock wise i.e. W = South, X = East, Y = West, Z = Midwest. This Means in Final 4 you have W vs. Z and X vs. Y.
                       Game5 = c(rep(2,16),rep(1,16),rep(1,16),rep(2,16)), # final 4 two games 4 numbers
                       Game6 = c(rep(1,64))) # championship 1 game 2 numbers 
```

```{r}
Tourney
```


Create Blank Tourney Table
```{r}
Tourney_Blank <-  data.frame(Team = rep(NA, 64), 
Seed = c("W01", "W16", "W02", "W15", "W03","W14", "W04","W13",
         "W05","W12","W06", "W11", "W07","W10", "W08","W09",
         "X01", "X16", "X02", "X15", "X03","X14", "X04","X13",
         "X05","X12","X06", "X11", "X07","X10", "X08","X09","Y01",
         "Y16", "Y02", "Y15", "Y03","Y14", "Y04","Y13", 
         "Y05","Y12","Y06", "Y11", "Y07","Y10", "Y08","Y09",
         "Z01", "Z16", "Z02", "Z15", "Z03","Z14", "Z04","Z13",
         "Z05","Z12","Z06", "Z11", "Z07","Z10", "Z08","Z09"), 


# Work from outsides of range building into the median to create WO1 vs. WO16 and so on reference the march madness brcket. 

Game = c(1,1, 2,2, 3,3,4, 4,5, 5,6, 6,7, 7, 8, 8, 9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17, 17, 18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32),

Game2 = c(1,1,2,2,3,3,4,4,4,4,3,3,2,2,1,1,5,5,6,6,7,7,8,8,8,8,7,7,6,6,5,5,9,9,10,10,11,11,12,12,12,12,11,11,10,10,9,9,13,13,14,14,15,15,16,16,16,16,15,15,14,14,13,13), # Up to 16
Game3 = c(1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,3,3,4,4,4,4,3,3,3,3,4,4,4,4,3,3,5,5,6,6,6,6,5,5,5,5,6,6,6,6,5,5,7,7,8,8,8,8,7,7,7,7,8,8,8,8,7,7), # Start with 8 1s up until 8
Game4 = c(rep(1,16), rep(2,16), rep(3,16), rep(4,16)), # 16 1s up until 4

### This needs reviewed, but I am making the assumption the bracked quadrants are labeled clock wise i.e. W = South, X = East, Y = West, Z = Midweat. This Means in Final 4 you have W vs. Z and X vs. Y.
Game5 = c(rep(2,16),rep(1,16),rep(1,16),rep(2,16)), # final 4 two games 4 numbers
Game6 = c(rep(1,64)) # championship 1 game 2 numbers 
)
```



```{r}
full_data <- subset(full_data, select= c(opponent_away, team_home, date, avg_poss_length_off_home, avg_poss_length_def_home, adj2fp_home, off_e_fg_pct_home, off_to_pct_home, off_or_pct_home, off_ft_rate_home, def_e_fg_pct_home, def_to_pct_home, def_or_pct_home, def_ft_rate_home, avg_hgt_home, eff_hgt_home, experience_home, bench_home, continuity_home, off_ft_pct_home, off_fg_2_pct_home, off_fg_3_pct_home, def_ft_pct_home, def_fg_2_pct_home, def_fg_3_pct_home, off_blk_pct_home, off_a_pct_home, def_blk_pct_home, def_a_pct_home, avg_poss_length_off_away, avg_poss_length_def_away, adj2fp_away, off_e_fg_pct_away, off_to_pct_away, off_or_pct_away, off_ft_rate_away, def_e_fg_pct_away, def_to_pct_away, def_or_pct_away, def_ft_rate_away, avg_hgt_away,eff_hgt_away, experience_away, bench_away, continuity_away, off_ft_pct_away, off_fg_2_pct_away, off_fg_3_pct_away, def_ft_pct_away, def_fg_2_pct_away, def_fg_3_pct_away, off_blk_pct_away, off_a_pct_away, def_blk_pct_away, def_a_pct_away))
#full_data <- full_data[, c("opponent_away", "team_home", "avg_poss_length_off_home", "avg_poss_length_def_home", "adj2fp_home, off_e_fg_pct_home", "off_to_pct_home", "off_or_pct_home", "off_ft_rate_home", "def_e_fg_pct_home", "def_to_pct_home", "def_or_pct_home", "def_ft_rate_home", "avg_hgt_home", "eff_hgt_home", "experience_home", "bench_home", "continuity_home", "off_ft_pct_home", "off_fg_2_pct_home", "off_fg_3_pct_home", "def_ft_pct_home", "def_fg_2_pct_home", "def_fg_3_pct_home", "off_blk_pct_home", "off_a_pct_home", "def_blk_pct_home", "def_a_pct_home", "avg_poss_length_off_away", "avg_poss_length_def_away", "adj2fp_away", "off_e_fg_pct_away", "off_to_pct_away", "off_or_pct_away", "off_ft_rate_away", "def_e_fg_pct_away", "def_to_pct_away", "def_or_pct_away", "def_ft_rate_away", "avg_hgt_away", "eff_hgt_away", "experience_away", "bench_away", "continuity_away", "off_ft_pct_away", "off_fg_2_pct_away", "off_fg_3_pct_away", "def_ft_pct_away", "def_fg_2_pct_away", "def_fg_3_pct_away", "off_blk_pct_away", "off_a_pct_away", "def_blk_pct_away", "def_a_pct_away")]
head(full_data)
```

```{r}
names(full_data)
team_names <- unique(c(full_data$team_home,full_data$opponent_away))
length(team_names)

team_stats <- as.data.frame(matrix(NA,nrow = length(team_names),ncol = 26))
names(full_data)
for(i in 1:length(team_names)){
  home_games <- full_data[full_data$team_home == team_names[i],]
  away_games <- full_data[full_data$opponent_away == team_names[i],]
  if(nrow(home_games) > 0 & nrow(away_games) > 0){
    if(home_games$date[nrow(home_games)] > away_games$date[nrow(away_games)]){
      team_stats[i,] <- home_games[nrow(home_games),c(4:30)]
    }else{
      team_stats[i,] <- away_games[nrow(away_games),c(31:55)]
    }
  }else if(nrow(home_games) > 0 & nrow(away_games) == 0){
    team_stats[i,] <- home_games[nrow(home_games),c(4:30)]
  }else if(nrow(home_games) == 0 & nrow(away_games) > 0){
    team_stats[i,] <- away_games[nrow(away_games),c(31:55)]
  }
  
}

# Add team column to data frame
team_stats$name <- team_names 
head(team_stats)

# Select random teams - Change when putting actual teams in

name_vec <- c("avg_poss_length_off_home", "avg_poss_length_def_home", "adj2fp_home", "off_e_fg_pct_home", "off_to_pct_home", "off_or_pct_home", "off_ft_rate_home", "def_e_fg_pct_home", "def_to_pct_home", "def_or_pct_home", "def_ft_rate_home", "avg_hgt_home", "eff_hgt_home", "experience_home", "bench_home", "continuity_home", "off_ft_pct_home", "off_fg_2_pct_home", "off_fg_3_pct_home", "def_ft_pct_home", "def_fg_2_pct_home", "def_fg_3_pct_home", "off_blk_pct_home", "off_a_pct_home", "def_blk_pct_home", "def_a_pct_home", "avg_poss_length_off_away", "avg_poss_length_def_away", "adj2fp_away", "off_e_fg_pct_away", "off_to_pct_away", "off_or_pct_away", "off_ft_rate_away", "def_e_fg_pct_away", "def_to_pct_away", "def_or_pct_away", "def_ft_rate_away", "avg_hgt_away", "eff_hgt_away", "experience_away", "bench_away", "continuity_away", "off_ft_pct_away", "off_fg_2_pct_away", "off_fg_3_pct_away", "def_ft_pct_away", "def_fg_2_pct_away", "def_fg_3_pct_away", "off_blk_pct_away", "off_a_pct_away", "def_blk_pct_away", "def_a_pct_away")
length(name_vec)

```




```{r}
round2 <-  rep(NA, 64)
#Round 1 
for (i in 1:32){
  teams <-  Tourney$Team[which(Tourney$Game == i)]
  print(teams)
 #join into single vector
  new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26], 
                             team_stats[which(team_stats$name == teams[2]),1:26])
  
  # Set names
  names(new_db) <- c(name_vec)
  
  #create dtrain object 
  
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  print(temp_data_2)
  
  pred <-  predict(bst_final, temp_data_2) #Feature names are different? 
  print(pred)
  sim <- runif(1, min = 0.10, max = .90)
  print(sim)
  if (pred < sim){
    round2[which(Tourney$Team == teams[2])] <-  Tourney$Game2[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
  }
  else{
    round2[which(Tourney$Team == teams[1])] <- Tourney$Game2[which(Tourney$Team == teams[1])]
  }
}

print(round2)
Tourney$round2 <- round2

Tourney$round2

print(Tourney)



round3 <-  rep(NA, 64)

#Round of 32
for (i in 1:16){
  teams <-  Tourney$Team[which(Tourney$round2 == i)]
  print(teams)
 #join into single vector
  new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  
  
  # Set names
  names(new_db) <- c(name_vec)
  
  #create dtrain object 
  
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  
  pred <-  predict(bst_final, temp_data_2)
  sim <- runif(1, min = 0.10, max = .90)
  if (pred < sim){
    round3[which(Tourney$Team == teams[2])] <- Tourney$Game3[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round3[which(Tourney$Team == teams[1])] <- Tourney$Game3[which(Tourney$Team == teams[1])]
  }
}


Tourney$round3 <- round3

Tourney

round4 <-  rep(NA, 64)


for (i in 1:8){
  teams <-  Tourney$Team[which(Tourney$round3 == i)]
  new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  
  
  # Set names
  names(new_db) <- c(name_vec)
  
  #create dtrain object 
  
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  
  pred <-  predict(bst_final, temp_data_2)
  sim <- runif(1, min = 0.10, max = 0.90)
  if (pred < sim){
    round4[which(Tourney$Team == teams[2])] <-  Tourney$Game4[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round4[which(Tourney$Team== teams[1])] <- Tourney$Game4[which(Tourney$Team == teams[1])]
  }
}


Tourney$round4 <-  round4


round5 <-  rep(NA, 64)


for (i in 1:4){
  teams <-  Tourney$Team[which(Tourney$round4 == i)]
  new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  names(new_db) <- c(name_vec)
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  
  pred <-  predict(bst_final, temp_data_2)
  sim <- runif(1, min = 0.10, max = 0.90)
  if (pred < sim){
    round5[which(Tourney$Team == teams[2])] <-  Tourney$Game5[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round5[which(Tourney$Team == teams[1])] <- Tourney$Game5[which(Tourney$Team == teams[1])]
  }
}



Tourney$round5 <- round5



round6 <-  rep(NA, 64) 


for (i in 1:2){
  teams <-  Tourney$Team[which(Tourney$round5 == i)]
 new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  names(new_db) <- c(name_vec)
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  
  pred <-  predict(bst_final, temp_data_2)
  sim <- runif(1, min = 0.10, max = 0.90)
  if (pred < sim){
    round6[which(Tourney$Team == teams[2])] <-  Tourney$Game6[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round6[which(Tourney$Team == teams[1])] <- Tourney$Game6[which(Tourney$Team == teams[1])]
  }
}



Tourney$round6 <- round6

winner <-  rep(NA, 64) 

teams <-  Tourney$Team[which(Tourney$round6 == 1)]
 new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  names(new_db) <- c(name_vec)
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  
  pred <-  predict(bst_final, temp_data_2)
  sim <- runif(1, min = 0.10, max = 0.90)
  if (pred < sim){
    winner[which(Tourney$Team == teams[2])] <-  Tourney$Game6[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }else{
    winner[which(Tourney$Team == teams[1])] <- Tourney$Game6[which(Tourney$Team == teams[1])]
  }
  
Tourney$winner <- winner
```

```{r}
Tourney
```


Bracket Output (1 Simulation)

There is something wrong with the bottom left final four side with the ifelse statement

```{r}
############## LOAD BLANK BRACKET #######

#install.packages("magick")
library(magick)
str(magick::magick_config())
bracket <- image_read("bracket2.jpg")
bracket <- image_convert(bracket, "png")
bracket <- image_scale(bracket, "1600")
bracket

############## TOP LEFT #################
tictoc::tic()
#load bracket
#Initial Bracket
bracket <- image_annotate(bracket, Tourney$Team[1], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+230") #zags 1
bracket <- image_annotate(bracket, Tourney$Team[2], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+262") #gstate 16
bracket <- image_annotate(bracket, Tourney$Team[3], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+675") #duke 2
bracket <- image_annotate(bracket, Tourney$Team[4], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+707") #cal 15
bracket <- image_annotate(bracket, Tourney$Team[5], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+548") #textec 3
bracket <- image_annotate(bracket, Tourney$Team[6], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+580") #mont 14
bracket <- image_annotate(bracket, Tourney$Team[7], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+355") #ark 4
bracket <- image_annotate(bracket, Tourney$Team[8], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+387") #verm 13
bracket <- image_annotate(bracket, Tourney$Team[9], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+420") #conn 5
bracket <- image_annotate(bracket, Tourney$Team[10], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+452") #nmex 12
bracket <- image_annotate(bracket, Tourney$Team[11], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+483") #bama 6
bracket <- image_annotate(bracket, Tourney$Team[12], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+515") #nd 11
bracket <- image_annotate(bracket, Tourney$Team[13], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+612") #michst 7
bracket <- image_annotate(bracket, Tourney$Team[14], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+644") #dav 10
bracket <- image_annotate(bracket, Tourney$Team[15], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+292") #boise 8
bracket <- image_annotate(bracket, Tourney$Team[16], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+324") #mem 9

#round of 32
bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[1])) 
{
    Tourney$Team[1]  # Statement
}else{
    Tourney$Team[2]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+242")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[3])) 
{
    Tourney$Team[3]  # Statement
}else{
    Tourney$Team[4]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+687")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[5])) 
{
    Tourney$Team[5]  # Statement
}else{
    Tourney$Team[6]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+560")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[7]))
{
    Tourney$Team[7]  # Statement
}else{
    Tourney$Team[8]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+367")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[9]))
{
    Tourney$Team[9]  # Statement
}else{
    Tourney$Team[10]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+432")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[11]))
{
    Tourney$Team[11]  # Statement
}else{
    Tourney$Team[12]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+496")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[13])) 
{
    Tourney$Team[13]  # Statement
}else{
    Tourney$Team[14]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+626")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[15])) 
{
    Tourney$Team[15]  # Statement
}else{
    Tourney$Team[16]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+307")

#sweet 16
bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[1])) {
    Tourney$Team[1]
} else if (!is.na(Tourney$round3[2])) {
    Tourney$Team[2]
} else if (!is.na(Tourney$round3[15])) {
    Tourney$Team[15]
} else {
 Tourney$Team[16]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+310+270")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[7])) {
    Tourney$Team[7]
} else if (!is.na(Tourney$round3[8])) {
    Tourney$Team[8]
} else if (!is.na(Tourney$round3[9])) {
    Tourney$Team[9]
} else {
 Tourney$Team[10]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+310+395")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[11])) {
    Tourney$Team[11]
} else if (!is.na(Tourney$round3[12])) {
    Tourney$Team[12]
} else if (!is.na(Tourney$round3[5])) {
    Tourney$Team[5]
} else {
 Tourney$Team[6]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+310+525")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[13])) {
    Tourney$Team[13]
} else if (!is.na(Tourney$round3[14])) {
    Tourney$Team[14]
} else if (!is.na(Tourney$round3[3])) {
    Tourney$Team[3]
} else {
 Tourney$Team[4]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+310+650")


#elite 8
bracket <- image_annotate(bracket, if(!is.na(Tourney$round4[1])) {
    Tourney$Team[1]
} else if (!is.na(Tourney$round4[2])) {
    Tourney$Team[2]
} else if (!is.na(Tourney$round4[15])) {
    Tourney$Team[15]
} else if (!is.na(Tourney$round4[16])) {
    Tourney$Team[16]
} else if (!is.na(Tourney$round4[15])) {
    Tourney$Team[15]
} else if (!is.na(Tourney$round4[7])) {
    Tourney$Team[7]
} else if (!is.na(Tourney$round4[8])) {
    Tourney$Team[8]
} else if (!is.na(Tourney$round4[9])) {
    Tourney$Team[9]
} else {
 Tourney$Team[10]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+435+335")


bracket <- image_annotate(bracket, if(!is.na(Tourney$round4[11])) {
    Tourney$Team[11]
} else if (!is.na(Tourney$round4[12])) {
    Tourney$Team[12]
} else if (!is.na(Tourney$round4[5])) {
    Tourney$Team[5]
} else if (!is.na(Tourney$round4[6])) {
    Tourney$Team[6]
} else if (!is.na(Tourney$round4[6])) {
    Tourney$Team[6]
} else if (!is.na(Tourney$round4[13])) {
    Tourney$Team[13]
} else if (!is.na(Tourney$round4[14])) {
    Tourney$Team[14]
} else if (!is.na(Tourney$round4[3])) {
    Tourney$Team[3]
} else {
 Tourney$Team[4]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+435+585")

#final four
bracket <- image_annotate(bracket, if(!is.na(Tourney$round5[11])) {
    Tourney$Team[11]
} else if (!is.na(Tourney$round5[12])) {
    Tourney$Team[12]
} else if (!is.na(Tourney$round5[5])) {
    Tourney$Team[5]
} else if (!is.na(Tourney$round5[6])) {
    Tourney$Team[6]
} else if (!is.na(Tourney$round5[6])) {
    Tourney$Team[6]
} else if (!is.na(Tourney$round5[13])) {
    Tourney$Team[13]
} else if (!is.na(Tourney$round5[14])) {
    Tourney$Team[14]
} else if (!is.na(Tourney$round5[3])) {
    Tourney$Team[3]
} else if (!is.na(Tourney$round5[14])) {
    Tourney$Team[14]
} else if (!is.na(Tourney$round5[3])) {
    Tourney$Team[3]
} else if(!is.na(Tourney$round5[1])) {
    Tourney$Team[1]
} else if (!is.na(Tourney$round5[2])) {
    Tourney$Team[2]
} else if (!is.na(Tourney$round5[15])) {
    Tourney$Team[15]
} else if (!is.na(Tourney$round5[16])) {
    Tourney$Team[16]
} else if (!is.na(Tourney$round5[15])) {
    Tourney$Team[15]
} else if (!is.na(Tourney$round5[7])) {
    Tourney$Team[7]
} else if (!is.na(Tourney$round5[8])) {
    Tourney$Team[8]
} else if (!is.na(Tourney$round5[9])) {
    Tourney$Team[9]
} else {
 Tourney$Team[4]
}, size = 26, color = "Gray", font = "Avenir Next Condensed", location = "+565+455")


############## BOTTOM LEFT #################


bracket <- image_annotate(bracket, Tourney$Team[17], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+740") #baylor 1
bracket <- image_annotate(bracket, Tourney$Team[18], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+772") #nflok 16
bracket <- image_annotate(bracket, Tourney$Team[19], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+1185") #tucky 2
bracket <- image_annotate(bracket, Tourney$Team[20], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+1217") #skete 15
bracket <- image_annotate(bracket, Tourney$Team[21], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+1058") #purd 3
bracket <- image_annotate(bracket, Tourney$Team[22], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+1090") #yale 14
bracket <- image_annotate(bracket, Tourney$Team[23], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+865") #ucla 4
bracket <- image_annotate(bracket, Tourney$Team[24], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+897") #akron 13
bracket <- image_annotate(bracket, Tourney$Team[25], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+930") #smary 5
bracket <- image_annotate(bracket, Tourney$Team[26], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+962") #texas 12
bracket <- image_annotate(bracket, Tourney$Team[27], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+993") #vatech 6
bracket <- image_annotate(bracket, Tourney$Team[28], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+1025") #murr 11
bracket <- image_annotate(bracket, Tourney$Team[29], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+1122") #michst 7
bracket <- image_annotate(bracket, Tourney$Team[30], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+1154") #san 10
bracket <- image_annotate(bracket, Tourney$Team[31], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+802") #unc 8
bracket <- image_annotate(bracket, Tourney$Team[32], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+60+834") #marq 9

#round of 32
bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[17])) 
{
    Tourney$Team[17]  # Statement
}else{
    Tourney$Team[18]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+752")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[19])) 
{
    Tourney$Team[19]  # Statement
}else{
    Tourney$Team[20]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+1197")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[21])) 
{
    Tourney$Team[21]  # Statement
}else{
    Tourney$Team[22]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+1070")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[23]))
{
    Tourney$Team[23]  # Statement
}else{
    Tourney$Team[24]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+877")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[25]))
{
    Tourney$Team[25]  # Statement
}else{
    Tourney$Team[26]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+942")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[27]))
{
    Tourney$Team[27]  # Statement
}else{
    Tourney$Team[28]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+1006")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[29])) 
{
    Tourney$Team[29]  # Statement
}else{
    Tourney$Team[30]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+1136")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[31])) 
{
    Tourney$Team[31]  # Statement
}else{
    Tourney$Team[32]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+185+817")

#sweet 16
bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[17])) {
    Tourney$Team[17]
} else if (!is.na(Tourney$round3[18])) {
    Tourney$Team[18]
} else if (!is.na(Tourney$round3[31])) {
    Tourney$Team[31]
} else {
 Tourney$Team[32]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+310+780")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[23])) {
    Tourney$Team[23]
} else if (!is.na(Tourney$round3[24])) {
    Tourney$Team[24]
} else if (!is.na(Tourney$round3[25])) {
    Tourney$Team[25]
} else {
 Tourney$Team[26]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+310+905")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[27])) {
    Tourney$Team[27]
} else if (!is.na(Tourney$round3[28])) {
    Tourney$Team[28]
} else if (!is.na(Tourney$round3[21])) {
    Tourney$Team[21]
} else {
 Tourney$Team[22]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+310+1035")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[29])) {
    Tourney$Team[29]
} else if (!is.na(Tourney$round3[30])) {
    Tourney$Team[30]
} else if (!is.na(Tourney$round3[19])) {
    Tourney$Team[19]
} else {
 Tourney$Team[20]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+310+1160")


#elite 8
bracket <- image_annotate(bracket, if(!is.na(Tourney$round4[17])) {
    Tourney$Team[17]
} else if (!is.na(Tourney$round4[18])) {
    Tourney$Team[18]
} else if (!is.na(Tourney$round4[31])) {
    Tourney$Team[31]
} else if (!is.na(Tourney$round4[32])) {
    Tourney$Team[32]
} else if (!is.na(Tourney$round4[31])) {
    Tourney$Team[31]
} else if (!is.na(Tourney$round4[23])) {
    Tourney$Team[23]
} else if (!is.na(Tourney$round4[24])) {
    Tourney$Team[24]
} else if (!is.na(Tourney$round4[25])) {
    Tourney$Team[25]
} else {
 Tourney$Team[26]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+435+845")


bracket <- image_annotate(bracket, if(!is.na(Tourney$round4[27])) {
    Tourney$Team[27]
} else if (!is.na(Tourney$round4[28])) {
    Tourney$Team[28]
} else if (!is.na(Tourney$round4[21])) {
    Tourney$Team[21]
} else if (!is.na(Tourney$round4[22])) {
    Tourney$Team[22]
} else if (!is.na(Tourney$round4[22])) {
    Tourney$Team[22]
} else if (!is.na(Tourney$round4[29])) {
    Tourney$Team[29]
} else if (!is.na(Tourney$round4[30])) {
    Tourney$Team[30]
} else if (!is.na(Tourney$round4[19])) {
    Tourney$Team[19]
} else {
 Tourney$Team[20]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+435+1095")


#final four
bracket <- image_annotate(bracket, if(!is.na(Tourney$round5[27])) {
    Tourney$Team[27]
} else if (!is.na(Tourney$round5[28])) {
    Tourney$Team[28]
} else if (!is.na(Tourney$round5[21])) {
    Tourney$Team[21]
} else if (!is.na(Tourney$round5[22])) {
    Tourney$Team[22]
} else if (!is.na(Tourney$round5[22])) {
    Tourney$Team[22]
} else if (!is.na(Tourney$round5[29])) {
    Tourney$Team[29]
} else if (!is.na(Tourney$round5[30])) {
    Tourney$Team[30]
} else if (!is.na(Tourney$round5[19])) {
    Tourney$Team[19]
} else if (!is.na(Tourney$round5[30])) {
    Tourney$Team[30]
} else if (!is.na(Tourney$round5[19])) {
    Tourney$Team[19]
} else if(!is.na(Tourney$round5[17])) {
    Tourney$Team[17]
} else if (!is.na(Tourney$round5[18])) {
    Tourney$Team[18]
} else if (!is.na(Tourney$round5[31])) {
    Tourney$Team[31]
} else if (!is.na(Tourney$round5[32])) {
    Tourney$Team[32]
} else if (!is.na(Tourney$round5[31])) {
    Tourney$Team[31]
} else if (!is.na(Tourney$round5[23])) {
    Tourney$Team[23]
} else if (!is.na(Tourney$round5[24])) {
    Tourney$Team[24]
} else if (!is.na(Tourney$round5[25])) {
    Tourney$Team[25]
} else {
 Tourney$Team[4]
}, size = 26, color = "Gray", font = "Avenir Next Condensed", location = "+565+965")

############TOP RIGHT##############

bracket <- image_annotate(bracket, Tourney$Team[33], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+230") #baylor 1
bracket <- image_annotate(bracket, Tourney$Team[34], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+262") #nflok 16
bracket <- image_annotate(bracket, Tourney$Team[35], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+675") #tucky 2
bracket <- image_annotate(bracket, Tourney$Team[36], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+707") #skete 15
bracket <- image_annotate(bracket, Tourney$Team[37], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+548") #purd 3
bracket <- image_annotate(bracket, Tourney$Team[38], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+580") #yale 14
bracket <- image_annotate(bracket, Tourney$Team[39], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+355") #ucla 4
bracket <- image_annotate(bracket, Tourney$Team[40], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+387") #akron 13
bracket <- image_annotate(bracket, Tourney$Team[41], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+420") #smary 5
bracket <- image_annotate(bracket, Tourney$Team[42], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+452") #texas 12
bracket <- image_annotate(bracket, Tourney$Team[43], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+483") #vatech 6
bracket <- image_annotate(bracket, Tourney$Team[44], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+515") #murr 11
bracket <- image_annotate(bracket, Tourney$Team[45], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+612") #michst 7
bracket <- image_annotate(bracket, Tourney$Team[46], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+644") #san 10
bracket <- image_annotate(bracket, Tourney$Team[47], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+292") #unc 8
bracket <- image_annotate(bracket, Tourney$Team[48], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+324") #marq 9

#round of 32
bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[33])) 
{
    Tourney$Team[33]  # Statement
}else{
    Tourney$Team[34]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+242")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[35])) 
{
    Tourney$Team[35]  # Statement
}else{
    Tourney$Team[36]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+687")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[37])) 
{
    Tourney$Team[37]  # Statement
}else{
    Tourney$Team[38]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+560")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[39]))
{
    Tourney$Team[39]  # Statement
}else{
    Tourney$Team[40]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+367")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[41]))
{
    Tourney$Team[41]  # Statement
}else{
    Tourney$Team[42]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+432")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[43]))
{
    Tourney$Team[43]  # Statement
}else{
    Tourney$Team[44]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+496")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[45])) 
{
    Tourney$Team[45]  # Statement
}else{
    Tourney$Team[46]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+626")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[47])) 
{
    Tourney$Team[47]  # Statement
}else{
    Tourney$Team[48]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+307")

#sweet 16
bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[33])) {
    Tourney$Team[33]
} else if (!is.na(Tourney$round3[34])) {
    Tourney$Team[34]
} else if (!is.na(Tourney$round3[47])) {
    Tourney$Team[47]
} else {
 Tourney$Team[48]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1200+270")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[39])) {
    Tourney$Team[39]
} else if (!is.na(Tourney$round3[40])) {
    Tourney$Team[40]
} else if (!is.na(Tourney$round3[41])) {
    Tourney$Team[41]
} else {
 Tourney$Team[42]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1200+395")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[43])) {
    Tourney$Team[43]
} else if (!is.na(Tourney$round3[44])) {
    Tourney$Team[44]
} else if (!is.na(Tourney$round3[37])) {
    Tourney$Team[37]
} else {
 Tourney$Team[38]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1200+525")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[45])) {
    Tourney$Team[45]
} else if (!is.na(Tourney$round3[46])) {
    Tourney$Team[46]
} else if (!is.na(Tourney$round3[35])) {
    Tourney$Team[35]
} else {
 Tourney$Team[36]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1200+650")


#elite 8
bracket <- image_annotate(bracket, if(!is.na(Tourney$round4[33])) {
    Tourney$Team[33]
} else if (!is.na(Tourney$round4[34])) {
    Tourney$Team[34]
} else if (!is.na(Tourney$round4[47])) {
    Tourney$Team[47]
} else if (!is.na(Tourney$round4[48])) {
    Tourney$Team[48]
} else if (!is.na(Tourney$round4[47])) {
    Tourney$Team[47]
} else if (!is.na(Tourney$round4[39])) {
    Tourney$Team[39]
} else if (!is.na(Tourney$round4[40])) {
    Tourney$Team[40]
} else if (!is.na(Tourney$round4[41])) {
    Tourney$Team[41]
} else {
 Tourney$Team[42]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1080+335")


bracket <- image_annotate(bracket, if(!is.na(Tourney$round4[43])) {
    Tourney$Team[43]
} else if (!is.na(Tourney$round4[44])) {
    Tourney$Team[44]
} else if (!is.na(Tourney$round4[37])) {
    Tourney$Team[37]
} else if (!is.na(Tourney$round4[38])) {
    Tourney$Team[38]
} else if (!is.na(Tourney$round4[38])) {
    Tourney$Team[38]
} else if (!is.na(Tourney$round4[45])) {
    Tourney$Team[45]
} else if (!is.na(Tourney$round4[46])) {
    Tourney$Team[46]
} else if (!is.na(Tourney$round4[35])) {
    Tourney$Team[35]
} else {
 Tourney$Team[36]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1080+585")

#final four
bracket <- image_annotate(bracket, if(!is.na(Tourney$round5[43])) {
    Tourney$Team[43]
} else if (!is.na(Tourney$round5[44])) {
    Tourney$Team[44]
} else if (!is.na(Tourney$round5[37])) {
    Tourney$Team[37]
} else if (!is.na(Tourney$round5[38])) {
    Tourney$Team[38]
} else if (!is.na(Tourney$round5[38])) {
    Tourney$Team[38]
} else if (!is.na(Tourney$round5[45])) {
    Tourney$Team[45]
} else if (!is.na(Tourney$round5[46])) {
    Tourney$Team[46]
} else if (!is.na(Tourney$round5[35])) {
    Tourney$Team[35]
} else if (!is.na(Tourney$round5[46])) {
    Tourney$Team[46]
} else if (!is.na(Tourney$round5[35])) {
    Tourney$Team[35]
} else if(!is.na(Tourney$round5[33])) {
    Tourney$Team[33]
} else if (!is.na(Tourney$round5[34])) {
    Tourney$Team[34]
} else if (!is.na(Tourney$round5[47])) {
    Tourney$Team[47]
} else if (!is.na(Tourney$round5[48])) {
    Tourney$Team[48]
} else if (!is.na(Tourney$round5[47])) {
    Tourney$Team[47]
} else if (!is.na(Tourney$round5[39])) {
    Tourney$Team[39]
} else if (!is.na(Tourney$round5[40])) {
    Tourney$Team[40]
} else if (!is.na(Tourney$round5[41])) {
    Tourney$Team[41]
} else {
 Tourney$Team[4]
}, size = 26, color = "Gray", font = "Avenir Next Condensed", location = "+950+455")

############ BOTTOM RIGHT ##########
bracket <- image_annotate(bracket, Tourney$Team[49], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+740") #baylor 1
bracket <- image_annotate(bracket, Tourney$Team[50], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+772") #nflok 16
bracket <- image_annotate(bracket, Tourney$Team[51], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+1185") #tucky 2
bracket <- image_annotate(bracket, Tourney$Team[52], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+1217") #skete 15
bracket <- image_annotate(bracket, Tourney$Team[53], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+1058") #purd 3
bracket <- image_annotate(bracket, Tourney$Team[54], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+1090") #yale 14
bracket <- image_annotate(bracket, Tourney$Team[55], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+865") #ucla 4
bracket <- image_annotate(bracket, Tourney$Team[56], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+897") #akron 13
bracket <- image_annotate(bracket, Tourney$Team[57], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+930") #smary 5
bracket <- image_annotate(bracket, Tourney$Team[58], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+962") #texas 12
bracket <- image_annotate(bracket, Tourney$Team[59], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+993") #vatech 6
bracket <- image_annotate(bracket, Tourney$Team[60], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+1025") #murr 11
bracket <- image_annotate(bracket, Tourney$Team[61], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+1120") #michst 7
bracket <- image_annotate(bracket, Tourney$Team[62], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+1154") #san 10
bracket <- image_annotate(bracket, Tourney$Team[63], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+802") #unc 8
bracket <- image_annotate(bracket, Tourney$Team[64], size = 16, color = "Gray", font = "Avenir Next Condensed", location = "+1445+834") #marq 9

#round of 32
bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[49])) 
{
    Tourney$Team[49]  # Statement
}else{
    Tourney$Team[50]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+752")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[51])) 
{
    Tourney$Team[51]  # Statement
}else{
    Tourney$Team[52]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+1197")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[53])) 
{
    Tourney$Team[53]  # Statement
}else{
    Tourney$Team[54]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+1070")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[55]))
{
    Tourney$Team[55]  # Statement
}else{
    Tourney$Team[56]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+877")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[57]))
{
    Tourney$Team[57]  # Statement
}else{
    Tourney$Team[58]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+942")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[59]))
{
    Tourney$Team[59]  # Statement
}else{
    Tourney$Team[60]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+1006")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[61])) 
{
    Tourney$Team[61]  # Statement
}else{
    Tourney$Team[62]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+1136")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round2[63])) 
{
    Tourney$Team[63]  # Statement
}else{
    Tourney$Team[64]
}, size = 20, color = "Gray", font = "Avenir Next Condensed", location = "+1310+817")

#sweet 16
bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[49])) {
    Tourney$Team[49]
} else if (!is.na(Tourney$round3[50])) {
    Tourney$Team[50]
} else if (!is.na(Tourney$round3[63])) {
    Tourney$Team[63]
} else {
 Tourney$Team[64]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1200+780")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[55])) {
    Tourney$Team[55]
} else if (!is.na(Tourney$round3[56])) {
    Tourney$Team[56]
} else if (!is.na(Tourney$round3[57])) {
    Tourney$Team[57]
} else {
 Tourney$Team[58]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1200+905")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[59])) {
    Tourney$Team[59]
} else if (!is.na(Tourney$round3[60])) {
    Tourney$Team[60]
} else if (!is.na(Tourney$round3[53])) {
    Tourney$Team[53]
} else {
 Tourney$Team[54]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1200+1035")

bracket <- image_annotate(bracket, if(!is.na(Tourney$round3[61])) {
    Tourney$Team[61]
} else if (!is.na(Tourney$round3[62])) {
    Tourney$Team[62]
} else if (!is.na(Tourney$round3[51])) {
    Tourney$Team[51]
} else {
 Tourney$Team[52]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1200+1160")


#elite 8
bracket <- image_annotate(bracket, if(!is.na(Tourney$round4[49])) {
    Tourney$Team[49]
} else if (!is.na(Tourney$round4[50])) {
    Tourney$Team[50]
} else if (!is.na(Tourney$round4[63])) {
    Tourney$Team[63]
} else if (!is.na(Tourney$round4[64])) {
    Tourney$Team[64]
} else if (!is.na(Tourney$round4[63])) {
    Tourney$Team[63]
} else if (!is.na(Tourney$round4[55])) {
    Tourney$Team[55]
} else if (!is.na(Tourney$round4[56])) {
    Tourney$Team[56]
} else if (!is.na(Tourney$round4[57])) {
    Tourney$Team[57]
} else {
 Tourney$Team[58]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1080+845")


bracket <- image_annotate(bracket, if(!is.na(Tourney$round4[59])) {
    Tourney$Team[59]
} else if (!is.na(Tourney$round4[60])) {
    Tourney$Team[60]
} else if (!is.na(Tourney$round4[53])) {
    Tourney$Team[53]
} else if (!is.na(Tourney$round4[54])) {
    Tourney$Team[54]
} else if (!is.na(Tourney$round4[54])) {
    Tourney$Team[54]
} else if (!is.na(Tourney$round4[61])) {
    Tourney$Team[61]
} else if (!is.na(Tourney$round4[62])) {
    Tourney$Team[62]
} else if (!is.na(Tourney$round4[51])) {
    Tourney$Team[51]
} else {
 Tourney$Team[52]
}, size = 22, color = "Gray", font = "Avenir Next Condensed", location = "+1080+1095")

#final four
bracket <- image_annotate(bracket, if(!is.na(Tourney$round5[59])) {
    Tourney$Team[59]
} else if (!is.na(Tourney$round5[60])) {
    Tourney$Team[60]
} else if (!is.na(Tourney$round5[53])) {
    Tourney$Team[53]
} else if (!is.na(Tourney$round5[54])) {
    Tourney$Team[54]
} else if (!is.na(Tourney$round5[54])) {
    Tourney$Team[54]
} else if (!is.na(Tourney$round5[61])) {
    Tourney$Team[61]
} else if (!is.na(Tourney$round5[62])) {
    Tourney$Team[62]
} else if (!is.na(Tourney$round5[51])) {
    Tourney$Team[51]
} else if (!is.na(Tourney$round5[62])) {
    Tourney$Team[62]
} else if (!is.na(Tourney$round5[51])) {
    Tourney$Team[51]
} else if(!is.na(Tourney$round5[49])) {
    Tourney$Team[49]
} else if (!is.na(Tourney$round5[50])) {
    Tourney$Team[50]
} else if (!is.na(Tourney$round5[63])) {
    Tourney$Team[63]
} else if (!is.na(Tourney$round5[64])) {
    Tourney$Team[64]
} else if (!is.na(Tourney$round5[63])) {
    Tourney$Team[63]
} else if (!is.na(Tourney$round5[55])) {
    Tourney$Team[55]
} else if (!is.na(Tourney$round5[56])) {
    Tourney$Team[56]
} else if (!is.na(Tourney$round5[57])) {
    Tourney$Team[57]
} else {
 Tourney$Team[4]
}, size = 26, color = "Gray", font = "Avenir Next Condensed", location = "+950+965")


#####################CHAMPIONSHIP [left side]#########################

bracket <- image_annotate(bracket, if(!is.na(Tourney$round6[1])) {
    Tourney$Team[1]
} else if (!is.na(Tourney$round6[2])) {
    Tourney$Team[2]
} else if (!is.na(Tourney$round6[3])) {
    Tourney$Team[3]
} else if (!is.na(Tourney$round6[4])) {
    Tourney$Team[4]
} else if (!is.na(Tourney$round6[5])) {
    Tourney$Team[5]
} else if (!is.na(Tourney$round6[6])) {
    Tourney$Team[6]
} else if (!is.na(Tourney$round6[7])) {
    Tourney$Team[7]
} else if (!is.na(Tourney$round6[8])) {
    Tourney$Team[8]
} else if (!is.na(Tourney$round6[9])) {
    Tourney$Team[9]
} else if (!is.na(Tourney$round6[10])) {
    Tourney$Team[10]
} else if (!is.na(Tourney$round6[11])) {
    Tourney$Team[11]
} else if(!is.na(Tourney$round6[12])) {
    Tourney$Team[12]
} else if (!is.na(Tourney$round6[13])) {
    Tourney$Team[13]
} else if (!is.na(Tourney$round6[14])) {
    Tourney$Team[14]
} else if (!is.na(Tourney$round6[15])) {
    Tourney$Team[15]
} else if (!is.na(Tourney$round6[16])) {
    Tourney$Team[16]
} else if (!is.na(Tourney$round6[17])) {
    Tourney$Team[17]
} else if (!is.na(Tourney$round6[18])) {
    Tourney$Team[18]
} else if (!is.na(Tourney$round6[19])) {
    Tourney$Team[19]
} else if (!is.na(Tourney$round6[20])) {
    Tourney$Team[20]
} else if (!is.na(Tourney$round6[21])) {
    Tourney$Team[21]
} else if (!is.na(Tourney$round6[22])) {
    Tourney$Team[22]
} else if (!is.na(Tourney$round6[23])) {
    Tourney$Team[23]
} else if (!is.na(Tourney$round6[24])) {
    Tourney$Team[24]
} else if (!is.na(Tourney$round6[25])) {
    Tourney$Team[25]
} else if (!is.na(Tourney$round6[26])) {
    Tourney$Team[26]
} else if (!is.na(Tourney$round6[27])) {
    Tourney$Team[27]
} else if (!is.na(Tourney$round6[28])) {
    Tourney$Team[28]
} else if (!is.na(Tourney$round6[29])) {
    Tourney$Team[29]
} else if (!is.na(Tourney$round6[30])) {
    Tourney$Team[30]
} else if (!is.na(Tourney$round6[31])) {
    Tourney$Team[31]
} else {
 Tourney$Team[32]
}, size = 30, color = "Gray", font = "Avenir Next Condensed", location = "+690+580")

#####################CHAMPIONSHIP [right side]#########################
bracket <- image_annotate(bracket, if(!is.na(Tourney$round6[33])) {
    Tourney$Team[33]
} else if (!is.na(Tourney$round6[34])) {
    Tourney$Team[34]
} else if (!is.na(Tourney$round6[35])) {
    Tourney$Team[35]
} else if (!is.na(Tourney$round6[36])) {
    Tourney$Team[36]
} else if (!is.na(Tourney$round6[37])) {
    Tourney$Team[37]
} else if (!is.na(Tourney$round6[38])) {
    Tourney$Team[38]
} else if (!is.na(Tourney$round6[39])) {
    Tourney$Team[39]
} else if (!is.na(Tourney$round6[40])) {
    Tourney$Team[40]
} else if (!is.na(Tourney$round6[41])) {
    Tourney$Team[41]
} else if (!is.na(Tourney$round6[42])) {
    Tourney$Team[42]
} else if (!is.na(Tourney$round6[43])) {
    Tourney$Team[43]
} else if(!is.na(Tourney$round6[44])) {
    Tourney$Team[44]
} else if (!is.na(Tourney$round6[45])) {
    Tourney$Team[45]
} else if (!is.na(Tourney$round6[46])) {
    Tourney$Team[46]
} else if (!is.na(Tourney$round6[47])) {
    Tourney$Team[47]
} else if (!is.na(Tourney$round6[48])) {
    Tourney$Team[48]
} else if (!is.na(Tourney$round6[49])) {
    Tourney$Team[49]
} else if (!is.na(Tourney$round6[50])) {
    Tourney$Team[50]
} else if (!is.na(Tourney$round6[51])) {
    Tourney$Team[51]
} else if (!is.na(Tourney$round6[52])) {
    Tourney$Team[52]
} else if (!is.na(Tourney$round6[53])) {
    Tourney$Team[53]
} else if (!is.na(Tourney$round6[54])) {
    Tourney$Team[54]
} else if (!is.na(Tourney$round6[55])) {
    Tourney$Team[55]
} else if (!is.na(Tourney$round6[56])) {
    Tourney$Team[56]
} else if (!is.na(Tourney$round6[57])) {
    Tourney$Team[57]
} else if (!is.na(Tourney$round6[58])) {
    Tourney$Team[58]
} else if (!is.na(Tourney$round6[59])) {
    Tourney$Team[59]
} else if (!is.na(Tourney$round6[60])) {
    Tourney$Team[60]
} else if (!is.na(Tourney$round6[61])) {
    Tourney$Team[61]
} else if (!is.na(Tourney$round6[62])) {
    Tourney$Team[62]
} else if (!is.na(Tourney$round6[63])) {
    Tourney$Team[63]
} else {
 Tourney$Team[64]
}, size = 30, color = "Gray", font = "Avenir Next Condensed", location = "+800+830")

##################### WINNER #########################
bracket <- image_annotate(bracket, if(!is.na(Tourney$winner[1])) {
    Tourney$Team[1]
} else if (!is.na(Tourney$winner[2])) {
    Tourney$Team[2]
} else if (!is.na(Tourney$winner[3])) {
    Tourney$Team[3]
} else if (!is.na(Tourney$winner[4])) {
    Tourney$Team[4]
} else if (!is.na(Tourney$winner[5])) {
    Tourney$Team[5]
} else if (!is.na(Tourney$winner[6])) {
    Tourney$Team[6]
} else if (!is.na(Tourney$winner[7])) {
    Tourney$Team[7]
} else if (!is.na(Tourney$winner[8])) {
    Tourney$Team[8]
} else if (!is.na(Tourney$winner[9])) {
    Tourney$Team[9]
} else if (!is.na(Tourney$winner[10])) {
    Tourney$Team[10]
} else if (!is.na(Tourney$winner[11])) {
    Tourney$Team[11]
} else if(!is.na(Tourney$winner[12])) {
    Tourney$Team[12]
} else if (!is.na(Tourney$winner[13])) {
    Tourney$Team[13]
} else if (!is.na(Tourney$winner[14])) {
    Tourney$Team[14]
} else if (!is.na(Tourney$winner[15])) {
    Tourney$Team[15]
} else if (!is.na(Tourney$winner[16])) {
    Tourney$Team[16]
} else if (!is.na(Tourney$winner[17])) {
    Tourney$Team[17]
} else if (!is.na(Tourney$winner[18])) {
    Tourney$Team[18]
} else if (!is.na(Tourney$winner[19])) {
    Tourney$Team[19]
} else if (!is.na(Tourney$winner[20])) {
    Tourney$Team[20]
} else if (!is.na(Tourney$winner[21])) {
    Tourney$Team[21]
} else if (!is.na(Tourney$winner[22])) {
    Tourney$Team[22]
} else if (!is.na(Tourney$winner[23])) {
    Tourney$Team[23]
} else if (!is.na(Tourney$winner[24])) {
    Tourney$Team[24]
} else if (!is.na(Tourney$winner[25])) {
    Tourney$Team[25]
} else if (!is.na(Tourney$winner[26])) {
    Tourney$Team[26]
} else if (!is.na(Tourney$winner[27])) {
    Tourney$Team[27]
} else if (!is.na(Tourney$winner[28])) {
    Tourney$Team[28]
} else if (!is.na(Tourney$winner[29])) {
    Tourney$Team[29]
} else if (!is.na(Tourney$winner[30])) {
    Tourney$Team[30]
} else if (!is.na(Tourney$winner[31])) {
    Tourney$Team[31]
} else if (!is.na(Tourney$winner[32])) {
    Tourney$Team[32]
} else if (!is.na(Tourney$winner[33])) {
    Tourney$Team[33]
} else if (!is.na(Tourney$winner[34])) {
    Tourney$Team[34]
} else if (!is.na(Tourney$winner[35])) {
    Tourney$Team[35]
} else if (!is.na(Tourney$winner[36])) {
    Tourney$Team[36]
} else if (!is.na(Tourney$winner[37])) {
    Tourney$Team[37]
} else if (!is.na(Tourney$winner[38])) {
    Tourney$Team[38]
} else if (!is.na(Tourney$winner[39])) {
    Tourney$Team[39]
} else if (!is.na(Tourney$winner[40])) {
    Tourney$Team[40]
} else if (!is.na(Tourney$winner[41])) {
    Tourney$Team[41]
} else if (!is.na(Tourney$winner[42])) {
    Tourney$Team[42]
} else if (!is.na(Tourney$winner[43])) {
    Tourney$Team[43]
} else if(!is.na(Tourney$winner[44])) {
    Tourney$Team[44]
} else if (!is.na(Tourney$winner[45])) {
    Tourney$Team[45]
} else if (!is.na(Tourney$winner[46])) {
    Tourney$Team[46]
} else if (!is.na(Tourney$winner[47])) {
    Tourney$Team[47]
} else if (!is.na(Tourney$winner[48])) {
    Tourney$Team[48]
} else if (!is.na(Tourney$winner[49])) {
    Tourney$Team[49]
} else if (!is.na(Tourney$winner[50])) {
    Tourney$Team[50]
} else if (!is.na(Tourney$winner[51])) {
    Tourney$Team[51]
} else if (!is.na(Tourney$winner[52])) {
    Tourney$Team[52]
} else if (!is.na(Tourney$winner[53])) {
    Tourney$Team[53]
} else if (!is.na(Tourney$winner[54])) {
    Tourney$Team[54]
} else if (!is.na(Tourney$winner[55])) {
    Tourney$Team[55]
} else if (!is.na(Tourney$winner[56])) {
    Tourney$Team[56]
} else if (!is.na(Tourney$winner[57])) {
    Tourney$Team[57]
} else if (!is.na(Tourney$winner[58])) {
    Tourney$Team[58]
} else if (!is.na(Tourney$winner[59])) {
    Tourney$Team[59]
} else if (!is.na(Tourney$winner[60])) {
    Tourney$Team[60]
} else if (!is.na(Tourney$winner[61])) {
    Tourney$Team[61]
} else if (!is.na(Tourney$winner[62])) {
    Tourney$Team[62]
} else if (!is.na(Tourney$winner[63])) {
    Tourney$Team[63]
} else {
 Tourney$Team[64]
}, size = 30, color = "Gray", font = "Avenir Next Condensed", location = "+740+1135")


bracket
tictoc::toc() #this tic toc function is not even close to being correct.
```

Create a list, store all tournament results.

```{r}
set.seed(123456)
sim_res <- vector(mode = "list", length = 10000)
win <- rep(NA, 10000)
Tourney_base <-  data.frame(Team = c(#West:
  "Gonzaga", "GeorgiaState", "Duke", "CalStateFullerton", "TexasTech", "MontanaState", "Arkansas", "Vermont", "Connecticut", "NewMexicoState", "Alabama", "NotreDame", "MichiganState", "Davidson", "BoiseState", "Memphis",
  #East:
  "Baylor","NorfolkState", "Kentucky", "SaintPeters", "Purdue", "Yale", "UCLA", "Akron", "SaintMarys", "Indiana", "Texas", "VirginiaTech", "MurrayState", "SanFrancisco", "NorthCarolina","Marquette",
  #South:
  "Arizona","WrightState","Villanova","Delaware","Tennessee","Longwood","Illinois","Chattanooga","Houston","UAB","ColoradoState","Michigan","OhioState","LoyolaChicago","SetonHall","TCU",
  #Midwest:
  "Kansas","TexasSouthern","Auburn","JacksonvilleState","Wisconsin","Colgate","Providence","SouthDakotaState","Iowa","Richmond","LSU","IowaState","USC","MiamiFL","SanDiegoState","Creighton"),

                       Seed = c("W01", "W16", "W02", "W15", "W03","W14", "W04","W13",
                                "W05","W12","W06", "W11", "W07","W10", "W08","W09",
                                "X01", "X16", "X02", "X15", "X03","X14", "X04","X13",
                                "X05","X12","X06", "X11", "X07","X10", "X08","X09","Y01",
                                "Y16", "Y02", "Y15", "Y03","Y14", "Y04","Y13", 
                                "Y05","Y12","Y06", "Y11", "Y07","Y10", "Y08","Y09",
                                "Z01", "Z16", "Z02", "Z15", "Z03","Z14", "Z04","Z13",
                                "Z05","Z12","Z06", "Z11", "Z07","Z10", "Z08","Z09"),
                       
                       
                       # Work from outsides of range building into the median to create WO1 vs. WO16 and so on reference the march madness brcket. 
                       
                       Game = c(1,1, 2,2, 3,3,4, 4,5, 5,6, 6,7, 7, 8, 8, 9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17, 17, 18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32),
                       
                       Game2 = c(1,1,2,2,3,3,4,4,4,4,3,3,2,2,1,1,5,5,6,6,7,7,8,8,8,8,7,7,6,6,5,5,9,9,10,10,11,11,12,12,12,12,11,11,10,10,9,9,13,13,14,14,15,15,16,16,16,16,15,15,14,14,13,13), # Up to 16
                       Game3 = c(1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,3,3,4,4,4,4,3,3,3,3,4,4,4,4,3,3,5,5,6,6,6,6,5,5,5,5,6,6,6,6,5,5,7,7,8,8,8,8,7,7,7,7,8,8,8,8,7,7), # Start with 8 1s up until 8
                       Game4 = c(rep(1,16), rep(2,16), rep(3,16), rep(4,16)), # 16 1s up until 4
                       
                       ### This needs reviewed, but I am making the assumption the bracked quadrants are labeled clock wise i.e. W = South, X = East, Y = West, Z = Midwest. This Means in Final 4 you have W vs. Z and X vs. Y.
                       Game5 = c(rep(1,16),rep(1,16),rep(2,16),rep(2,16)), # final 4 two games 4 numbers
                       Game6 = c(rep(1,64)) # championship 1 game 2 numbers 
)



for (x in 1:10000){

  Tourney <- Tourney_base
  
round2 <-  rep(NA, 64)

#Round 1 
for (i in 1:32){
  teams <-  Tourney$Team[which(Tourney$Game == i)]
 
 #join into single vector
  new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  
  # Set names
  names(new_db) <- c(name_vec)
  
  #create dtrain object 
  
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))

  
  pred <-  predict(bst_final, temp_data_2)

  sim <- runif(1, min = 0.05, max = .95)

  if (pred < sim){
    round2[which(Tourney$Team == teams[2])] <-  Tourney$Game2[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
  }
  else{
    round2[which(Tourney$Team == teams[1])] <- Tourney$Game2[which(Tourney$Team == teams[1])]
  }
}


Tourney$round2 <- round2






round3 <-  rep(NA, 64)

#Round of 32
for (i in 1:16){
  teams <-  Tourney$Team[which(Tourney$round2 == i)]

 #join into single vector
  new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  
  
  # Set names
  names(new_db) <- c(name_vec)
  
  #create dtrain object 
  
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  
  pred <-  predict(bst_final, temp_data_2)

  sim <- runif(1, min = 0.05, max = 0.95)
  if (pred < sim){
    round3[which(Tourney$Team == teams[2])] <- Tourney$Game3[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round3[which(Tourney$Team == teams[1])] <- Tourney$Game3[which(Tourney$Team == teams[1])]
  }
}


Tourney$round3 <- round3



round4 <-  rep(NA, 64)


for (i in 1:8){
  teams <-  Tourney$Team[which(Tourney$round3 == i)]
  new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  
  
  # Set names
  names(new_db) <- c(name_vec)
  
  #create dtrain object 
  
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  
  pred <-  predict(bst_final, temp_data_2)
  sim <- runif(1, min = 0.05, max = 0.95)
  if (pred < sim){
    round4[which(Tourney$Team == teams[2])] <-  Tourney$Game4[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round4[which(Tourney$Team== teams[1])] <- Tourney$Game4[which(Tourney$Team == teams[1])]
  }
}


Tourney$round4 <-  round4


round5 <-  rep(NA, 64)


for (i in 1:4){
  teams <-  Tourney$Team[which(Tourney$round4 == i)]
  new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  names(new_db) <- c(name_vec)
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  
  pred <-  predict(bst_final, temp_data_2)
  sim <- runif(1, min = 0.05, max = 0.95)
  if (pred < sim){
    round5[which(Tourney$Team == teams[2])] <-  Tourney$Game5[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round5[which(Tourney$Team == teams[1])] <- Tourney$Game5[which(Tourney$Team == teams[1])]
  }
}



Tourney$round5 <- round5



round6 <-  rep(NA, 64) 


for (i in 1:2){
  teams <-  Tourney$Team[which(Tourney$round5 == i)]
 new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  names(new_db) <- c(name_vec)
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  
  pred <-  predict(bst_final, temp_data_2)
  sim <- runif(1, min = 0.05, max = 0.95)
  if (pred < sim){
    round6[which(Tourney$Team == teams[2])] <-  Tourney$Game6[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }
  else{
    round6[which(Tourney$Team == teams[1])] <- Tourney$Game6[which(Tourney$Team == teams[1])]
  }
}



Tourney$round6 <- round6

winner <-  rep(NA, 64) 

teams <-  Tourney$Team[which(Tourney$round6 == 1)]
 new_db <- cbind.data.frame(team_stats[which(team_stats$name == teams[1]),1:26],
                             team_stats[which(team_stats$name == teams[2]),1:26])
  names(new_db) <- c(name_vec)
  temp_data_2 <-  xgb.DMatrix(data = as.matrix(new_db))
  
  pred <-  predict(bst_final, temp_data_2)
  sim <- runif(1, min = 0.05, max = 0.95)
  if (pred < sim){
    winner[which(Tourney$Team == teams[2])] <-  Tourney$Game6[which(Tourney$Team == teams[2])] # assign round 2 game to team 2 if they were to win the game
    
    
  }else{
    winner[which(Tourney$Team == teams[1])] <- Tourney$Game6[which(Tourney$Team == teams[1])]
  }
  
Tourney$winner <- winner

sim_res[[x]] <- Tourney

win[x] <- Tourney$Team[!is.na(winner)]

}




```


```{r}
summary(as.factor(win))
```

```{r}
library(data.table)
tempres <- rbindlist(sim_res)
results_db <- as.data.frame(matrix(NA,nrow = nrow(Tourney),ncol = 6))
results_db$teams <- Tourney$Team
names(results_db)[1:6] <- c("Round_2","Round_3","Round_4","Round_5","Round_6","Winner")
for (i in 1:nrow(results_db)){
  team_res <- tempres[tempres$Team == results_db$teams[i],] 
  results_db[i,1] <- sum(!is.na(team_res$round2))
  results_db[i,2] <- sum(!is.na(team_res$round3))
  results_db[i,3] <- sum(!is.na(team_res$round4))
  results_db[i,4] <- sum(!is.na(team_res$round5))
  results_db[i,5] <- sum(!is.na(team_res$round6))
  results_db[i,6] <- sum(!is.na(team_res$winner))
}

print(results_db)
#save(results_db, file = "TournamentResults.rda")
write.csv(results_db,"tournamentresultsexcellalldata.csv" ,row.names = FALSE)

```

















